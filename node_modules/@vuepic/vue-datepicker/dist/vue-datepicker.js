import { openBlock as M, createElementBlock as W, createElementVNode as de, unref as c, reactive as Et, computed as Z, ref as ee, toRef as Zt, watch as dt, h as Ga, render as Qn, defineComponent as Oe, renderSlot as le, createCommentVNode as K, normalizeClass as be, withKeys as ue, createBlock as ge, withModifiers as ke, onMounted as ze, normalizeStyle as Xe, normalizeProps as Pe, mergeProps as Re, Fragment as ve, createTextVNode as rt, toDisplayString as Ye, onBeforeUpdate as qa, nextTick as ct, onUnmounted as Yn, renderList as Me, withDirectives as jt, vShow as Kt, withCtx as fe, createVNode as We, Transition as Pt, createSlots as Ee, useSlots as kt, guardReactiveProps as Fe, resolveDynamicComponent as Nn, getCurrentScope as Za, onScopeDispose as Qa, isRef as Xn, Teleport as Xa } from "vue";
import { format as st, isBefore as Yt, isEqual as $t, isAfter as Nt, set as De, setHours as ba, setMinutes as ka, setSeconds as In, setMilliseconds as Bn, getYear as ce, getMonth as he, setMonth as Ja, setYear as tt, addMonths as ht, subMonths as It, isValid as Gt, parseISO as xa, eachDayOfInterval as wa, getHours as Je, getMinutes as nt, getSeconds as Tt, startOfWeek as Da, endOfWeek as er, parse as Tn, isDate as tr, addYears as Ma, subYears as $a, addDays as yt, getDay as nr, differenceInCalendarDays as ar, add as Ta, sub as rr, getWeek as lr, getISOWeek as or, isSameQuarter as Jn, eachQuarterOfInterval as sr, startOfYear as ir, endOfYear as ur, startOfQuarter as dr, endOfQuarter as xn, getQuarter as ea } from "date-fns";
function Ft() {
  return M(), W(
    "svg",
    {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 32 32",
      fill: "currentColor",
      "aria-hidden": "true",
      class: "dp__icon"
    },
    [
      de("path", {
        d: "M29.333 8c0-2.208-1.792-4-4-4h-18.667c-2.208 0-4 1.792-4 4v18.667c0 2.208 1.792 4 4 4h18.667c2.208 0 4-1.792 4-4v-18.667zM26.667 8v18.667c0 0.736-0.597 1.333-1.333 1.333 0 0-18.667 0-18.667 0-0.736 0-1.333-0.597-1.333-1.333 0 0 0-18.667 0-18.667 0-0.736 0.597-1.333 1.333-1.333 0 0 18.667 0 18.667 0 0.736 0 1.333 0.597 1.333 1.333z"
      }),
      de("path", {
        d: "M20 2.667v5.333c0 0.736 0.597 1.333 1.333 1.333s1.333-0.597 1.333-1.333v-5.333c0-0.736-0.597-1.333-1.333-1.333s-1.333 0.597-1.333 1.333z"
      }),
      de("path", {
        d: "M9.333 2.667v5.333c0 0.736 0.597 1.333 1.333 1.333s1.333-0.597 1.333-1.333v-5.333c0-0.736-0.597-1.333-1.333-1.333s-1.333 0.597-1.333 1.333z"
      }),
      de("path", {
        d: "M4 14.667h24c0.736 0 1.333-0.597 1.333-1.333s-0.597-1.333-1.333-1.333h-24c-0.736 0-1.333 0.597-1.333 1.333s0.597 1.333 1.333 1.333z"
      })
    ]
  );
}
Ft.compatConfig = {
  MODE: 3
};
function Aa() {
  return M(), W(
    "svg",
    {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 32 32",
      fill: "currentColor",
      "aria-hidden": "true",
      class: "dp__icon"
    },
    [
      de("path", {
        d: "M23.057 7.057l-16 16c-0.52 0.52-0.52 1.365 0 1.885s1.365 0.52 1.885 0l16-16c0.52-0.52 0.52-1.365 0-1.885s-1.365-0.52-1.885 0z"
      }),
      de("path", {
        d: "M7.057 8.943l16 16c0.52 0.52 1.365 0.52 1.885 0s0.52-1.365 0-1.885l-16-16c-0.52-0.52-1.365-0.52-1.885 0s-0.52 1.365 0 1.885z"
      })
    ]
  );
}
Aa.compatConfig = {
  MODE: 3
};
function En() {
  return M(), W(
    "svg",
    {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 32 32",
      fill: "currentColor",
      "aria-hidden": "true",
      class: "dp__icon"
    },
    [
      de("path", {
        d: "M20.943 23.057l-7.057-7.057c0 0 7.057-7.057 7.057-7.057 0.52-0.52 0.52-1.365 0-1.885s-1.365-0.52-1.885 0l-8 8c-0.521 0.521-0.521 1.365 0 1.885l8 8c0.52 0.52 1.365 0.52 1.885 0s0.52-1.365 0-1.885z"
      })
    ]
  );
}
En.compatConfig = {
  MODE: 3
};
function Fn() {
  return M(), W(
    "svg",
    {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 32 32",
      fill: "currentColor",
      "aria-hidden": "true",
      class: "dp__icon"
    },
    [
      de("path", {
        d: "M12.943 24.943l8-8c0.521-0.521 0.521-1.365 0-1.885l-8-8c-0.52-0.52-1.365-0.52-1.885 0s-0.52 1.365 0 1.885l7.057 7.057c0 0-7.057 7.057-7.057 7.057-0.52 0.52-0.52 1.365 0 1.885s1.365 0.52 1.885 0z"
      })
    ]
  );
}
Fn.compatConfig = {
  MODE: 3
};
function Hn() {
  return M(), W(
    "svg",
    {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 32 32",
      fill: "currentColor",
      "aria-hidden": "true",
      class: "dp__icon"
    },
    [
      de("path", {
        d: "M16 1.333c-8.095 0-14.667 6.572-14.667 14.667s6.572 14.667 14.667 14.667c8.095 0 14.667-6.572 14.667-14.667s-6.572-14.667-14.667-14.667zM16 4c6.623 0 12 5.377 12 12s-5.377 12-12 12c-6.623 0-12-5.377-12-12s5.377-12 12-12z"
      }),
      de("path", {
        d: "M14.667 8v8c0 0.505 0.285 0.967 0.737 1.193l5.333 2.667c0.658 0.329 1.46 0.062 1.789-0.596s0.062-1.46-0.596-1.789l-4.596-2.298c0 0 0-7.176 0-7.176 0-0.736-0.597-1.333-1.333-1.333s-1.333 0.597-1.333 1.333z"
      })
    ]
  );
}
Hn.compatConfig = {
  MODE: 3
};
function Vn() {
  return M(), W(
    "svg",
    {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 32 32",
      fill: "currentColor",
      "aria-hidden": "true",
      class: "dp__icon"
    },
    [
      de("path", {
        d: "M24.943 19.057l-8-8c-0.521-0.521-1.365-0.521-1.885 0l-8 8c-0.52 0.52-0.52 1.365 0 1.885s1.365 0.52 1.885 0l7.057-7.057c0 0 7.057 7.057 7.057 7.057 0.52 0.52 1.365 0.52 1.885 0s0.52-1.365 0-1.885z"
      })
    ]
  );
}
Vn.compatConfig = {
  MODE: 3
};
function Un() {
  return M(), W(
    "svg",
    {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 32 32",
      fill: "currentColor",
      "aria-hidden": "true",
      class: "dp__icon"
    },
    [
      de("path", {
        d: "M7.057 12.943l8 8c0.521 0.521 1.365 0.521 1.885 0l8-8c0.52-0.52 0.52-1.365 0-1.885s-1.365-0.52-1.885 0l-7.057 7.057c0 0-7.057-7.057-7.057-7.057-0.52-0.52-1.365-0.52-1.885 0s-0.52 1.365 0 1.885z"
      })
    ]
  );
}
Un.compatConfig = {
  MODE: 3
};
function Ln(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var Sa = { exports: {} };
(function(e) {
  function t(r) {
    return r && r.__esModule ? r : {
      default: r
    };
  }
  e.exports = t, e.exports.__esModule = !0, e.exports.default = e.exports;
})(Sa);
var cr = Sa.exports, An = { exports: {} };
(function(e, t) {
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.default = r;
  function r(a) {
    if (a === null || a === !0 || a === !1)
      return NaN;
    var n = Number(a);
    return isNaN(n) ? n : n < 0 ? Math.ceil(n) : Math.floor(n);
  }
  e.exports = t.default;
})(An, An.exports);
var fr = An.exports;
const vr = /* @__PURE__ */ Ln(fr);
var Sn = { exports: {} };
(function(e, t) {
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.default = r;
  function r(a) {
    var n = new Date(Date.UTC(a.getFullYear(), a.getMonth(), a.getDate(), a.getHours(), a.getMinutes(), a.getSeconds(), a.getMilliseconds()));
    return n.setUTCFullYear(a.getFullYear()), a.getTime() - n.getTime();
  }
  e.exports = t.default;
})(Sn, Sn.exports);
var mr = Sn.exports;
const ta = /* @__PURE__ */ Ln(mr);
function gr(e, t) {
  var r = br(t);
  return r.formatToParts ? hr(r, e) : pr(r, e);
}
var yr = {
  year: 0,
  month: 1,
  day: 2,
  hour: 3,
  minute: 4,
  second: 5
};
function hr(e, t) {
  try {
    for (var r = e.formatToParts(t), a = [], n = 0; n < r.length; n++) {
      var o = yr[r[n].type];
      o >= 0 && (a[o] = parseInt(r[n].value, 10));
    }
    return a;
  } catch (i) {
    if (i instanceof RangeError)
      return [NaN];
    throw i;
  }
}
function pr(e, t) {
  var r = e.format(t).replace(/\u200E/g, ""), a = /(\d+)\/(\d+)\/(\d+),? (\d+):(\d+):(\d+)/.exec(r);
  return [a[3], a[1], a[2], a[4], a[5], a[6]];
}
var fn = {};
function br(e) {
  if (!fn[e]) {
    var t = new Intl.DateTimeFormat("en-US", {
      hour12: !1,
      timeZone: "America/New_York",
      year: "numeric",
      month: "numeric",
      day: "2-digit",
      hour: "2-digit",
      minute: "2-digit",
      second: "2-digit"
    }).format(/* @__PURE__ */ new Date("2014-06-25T04:00:00.123Z")), r = t === "06/25/2014, 00:00:00" || t === "‎06‎/‎25‎/‎2014‎ ‎00‎:‎00‎:‎00";
    fn[e] = r ? new Intl.DateTimeFormat("en-US", {
      hour12: !1,
      timeZone: e,
      year: "numeric",
      month: "numeric",
      day: "2-digit",
      hour: "2-digit",
      minute: "2-digit",
      second: "2-digit"
    }) : new Intl.DateTimeFormat("en-US", {
      hourCycle: "h23",
      timeZone: e,
      year: "numeric",
      month: "numeric",
      day: "2-digit",
      hour: "2-digit",
      minute: "2-digit",
      second: "2-digit"
    });
  }
  return fn[e];
}
function Wn(e, t, r, a, n, o, i) {
  var d = /* @__PURE__ */ new Date(0);
  return d.setUTCFullYear(e, t, r), d.setUTCHours(a, n, o, i), d;
}
var na = 36e5, kr = 6e4, vn = {
  timezone: /([Z+-].*)$/,
  timezoneZ: /^(Z)$/,
  timezoneHH: /^([+-]\d{2})$/,
  timezoneHHMM: /^([+-]\d{2}):?(\d{2})$/
};
function zn(e, t, r) {
  var a, n;
  if (e === "" || (a = vn.timezoneZ.exec(e), a))
    return 0;
  var o;
  if (a = vn.timezoneHH.exec(e), a)
    return o = parseInt(a[1], 10), aa(o) ? -(o * na) : NaN;
  if (a = vn.timezoneHHMM.exec(e), a) {
    o = parseInt(a[1], 10);
    var i = parseInt(a[2], 10);
    return aa(o, i) ? (n = Math.abs(o) * na + i * kr, o > 0 ? -n : n) : NaN;
  }
  if (Mr(e)) {
    t = new Date(t || Date.now());
    var d = r ? t : wr(t), b = Pn(d, e), P = r ? b : Dr(t, b, e);
    return -P;
  }
  return NaN;
}
function wr(e) {
  return Wn(
    e.getFullYear(),
    e.getMonth(),
    e.getDate(),
    e.getHours(),
    e.getMinutes(),
    e.getSeconds(),
    e.getMilliseconds()
  );
}
function Pn(e, t) {
  var r = gr(e, t), a = Wn(
    r[0],
    r[1] - 1,
    r[2],
    r[3] % 24,
    r[4],
    r[5],
    0
  ).getTime(), n = e.getTime(), o = n % 1e3;
  return n -= o >= 0 ? o : 1e3 + o, a - n;
}
function Dr(e, t, r) {
  var a = e.getTime(), n = a - t, o = Pn(new Date(n), r);
  if (t === o)
    return t;
  n -= o - t;
  var i = Pn(new Date(n), r);
  return o === i ? o : Math.max(o, i);
}
function aa(e, t) {
  return -23 <= e && e <= 23 && (t == null || 0 <= t && t <= 59);
}
var ra = {};
function Mr(e) {
  if (ra[e])
    return !0;
  try {
    return new Intl.DateTimeFormat(void 0, { timeZone: e }), ra[e] = !0, !0;
  } catch {
    return !1;
  }
}
var Pa = /(Z|[+-]\d{2}(?::?\d{2})?| UTC| [a-zA-Z]+\/[a-zA-Z_]+(?:\/[a-zA-Z_]+)?)$/, mn = 36e5, la = 6e4, $r = 2, Be = {
  dateTimePattern: /^([0-9W+-]+)(T| )(.*)/,
  datePattern: /^([0-9W+-]+)(.*)/,
  plainTime: /:/,
  // year tokens
  YY: /^(\d{2})$/,
  YYY: [
    /^([+-]\d{2})$/,
    // 0 additional digits
    /^([+-]\d{3})$/,
    // 1 additional digit
    /^([+-]\d{4})$/
    // 2 additional digits
  ],
  YYYY: /^(\d{4})/,
  YYYYY: [
    /^([+-]\d{4})/,
    // 0 additional digits
    /^([+-]\d{5})/,
    // 1 additional digit
    /^([+-]\d{6})/
    // 2 additional digits
  ],
  // date tokens
  MM: /^-(\d{2})$/,
  DDD: /^-?(\d{3})$/,
  MMDD: /^-?(\d{2})-?(\d{2})$/,
  Www: /^-?W(\d{2})$/,
  WwwD: /^-?W(\d{2})-?(\d{1})$/,
  HH: /^(\d{2}([.,]\d*)?)$/,
  HHMM: /^(\d{2}):?(\d{2}([.,]\d*)?)$/,
  HHMMSS: /^(\d{2}):?(\d{2}):?(\d{2}([.,]\d*)?)$/,
  // time zone tokens (to identify the presence of a tz)
  timeZone: Pa
};
function Cn(e, t) {
  if (arguments.length < 1)
    throw new TypeError("1 argument required, but only " + arguments.length + " present");
  if (e === null)
    return /* @__PURE__ */ new Date(NaN);
  var r = t || {}, a = r.additionalDigits == null ? $r : vr(r.additionalDigits);
  if (a !== 2 && a !== 1 && a !== 0)
    throw new RangeError("additionalDigits must be 0, 1 or 2");
  if (e instanceof Date || typeof e == "object" && Object.prototype.toString.call(e) === "[object Date]")
    return new Date(e.getTime());
  if (typeof e == "number" || Object.prototype.toString.call(e) === "[object Number]")
    return new Date(e);
  if (!(typeof e == "string" || Object.prototype.toString.call(e) === "[object String]"))
    return /* @__PURE__ */ new Date(NaN);
  var n = Tr(e), o = Ar(n.date, a), i = o.year, d = o.restDateString, b = Sr(d, i);
  if (isNaN(b))
    return /* @__PURE__ */ new Date(NaN);
  if (b) {
    var P = b.getTime(), T = 0, p;
    if (n.time && (T = Pr(n.time), isNaN(T)))
      return /* @__PURE__ */ new Date(NaN);
    if (n.timeZone || r.timeZone) {
      if (p = zn(n.timeZone || r.timeZone, new Date(P + T)), isNaN(p))
        return /* @__PURE__ */ new Date(NaN);
    } else
      p = ta(new Date(P + T)), p = ta(new Date(P + T + p));
    return new Date(P + T + p);
  } else
    return /* @__PURE__ */ new Date(NaN);
}
function Tr(e) {
  var t = {}, r = Be.dateTimePattern.exec(e), a;
  if (r ? (t.date = r[1], a = r[3]) : (r = Be.datePattern.exec(e), r ? (t.date = r[1], a = r[2]) : (t.date = null, a = e)), a) {
    var n = Be.timeZone.exec(a);
    n ? (t.time = a.replace(n[1], ""), t.timeZone = n[1].trim()) : t.time = a;
  }
  return t;
}
function Ar(e, t) {
  var r = Be.YYY[t], a = Be.YYYYY[t], n;
  if (n = Be.YYYY.exec(e) || a.exec(e), n) {
    var o = n[1];
    return {
      year: parseInt(o, 10),
      restDateString: e.slice(o.length)
    };
  }
  if (n = Be.YY.exec(e) || r.exec(e), n) {
    var i = n[1];
    return {
      year: parseInt(i, 10) * 100,
      restDateString: e.slice(i.length)
    };
  }
  return {
    year: null
  };
}
function Sr(e, t) {
  if (t === null)
    return null;
  var r, a, n, o;
  if (e.length === 0)
    return a = /* @__PURE__ */ new Date(0), a.setUTCFullYear(t), a;
  if (r = Be.MM.exec(e), r)
    return a = /* @__PURE__ */ new Date(0), n = parseInt(r[1], 10) - 1, sa(t, n) ? (a.setUTCFullYear(t, n), a) : /* @__PURE__ */ new Date(NaN);
  if (r = Be.DDD.exec(e), r) {
    a = /* @__PURE__ */ new Date(0);
    var i = parseInt(r[1], 10);
    return Rr(t, i) ? (a.setUTCFullYear(t, 0, i), a) : /* @__PURE__ */ new Date(NaN);
  }
  if (r = Be.MMDD.exec(e), r) {
    a = /* @__PURE__ */ new Date(0), n = parseInt(r[1], 10) - 1;
    var d = parseInt(r[2], 10);
    return sa(t, n, d) ? (a.setUTCFullYear(t, n, d), a) : /* @__PURE__ */ new Date(NaN);
  }
  if (r = Be.Www.exec(e), r)
    return o = parseInt(r[1], 10) - 1, ia(t, o) ? oa(t, o) : /* @__PURE__ */ new Date(NaN);
  if (r = Be.WwwD.exec(e), r) {
    o = parseInt(r[1], 10) - 1;
    var b = parseInt(r[2], 10) - 1;
    return ia(t, o, b) ? oa(t, o, b) : /* @__PURE__ */ new Date(NaN);
  }
  return null;
}
function Pr(e) {
  var t, r, a;
  if (t = Be.HH.exec(e), t)
    return r = parseFloat(t[1].replace(",", ".")), gn(r) ? r % 24 * mn : NaN;
  if (t = Be.HHMM.exec(e), t)
    return r = parseInt(t[1], 10), a = parseFloat(t[2].replace(",", ".")), gn(r, a) ? r % 24 * mn + a * la : NaN;
  if (t = Be.HHMMSS.exec(e), t) {
    r = parseInt(t[1], 10), a = parseInt(t[2], 10);
    var n = parseFloat(t[3].replace(",", "."));
    return gn(r, a, n) ? r % 24 * mn + a * la + n * 1e3 : NaN;
  }
  return null;
}
function oa(e, t, r) {
  t = t || 0, r = r || 0;
  var a = /* @__PURE__ */ new Date(0);
  a.setUTCFullYear(e, 0, 4);
  var n = a.getUTCDay() || 7, o = t * 7 + r + 1 - n;
  return a.setUTCDate(a.getUTCDate() + o), a;
}
var Cr = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31], _r = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
function Ca(e) {
  return e % 400 === 0 || e % 4 === 0 && e % 100 !== 0;
}
function sa(e, t, r) {
  if (t < 0 || t > 11)
    return !1;
  if (r != null) {
    if (r < 1)
      return !1;
    var a = Ca(e);
    if (a && r > _r[t] || !a && r > Cr[t])
      return !1;
  }
  return !0;
}
function Rr(e, t) {
  if (t < 1)
    return !1;
  var r = Ca(e);
  return !(r && t > 366 || !r && t > 365);
}
function ia(e, t, r) {
  return !(t < 0 || t > 52 || r != null && (r < 0 || r > 6));
}
function gn(e, t, r) {
  return !(e != null && (e < 0 || e >= 25) || t != null && (t < 0 || t >= 60) || r != null && (r < 0 || r >= 60));
}
var _n = { exports: {} }, Rn = { exports: {} };
(function(e, t) {
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.default = r;
  function r(a, n) {
    if (a == null)
      throw new TypeError("assign requires that input parameter not be null or undefined");
    for (var o in n)
      Object.prototype.hasOwnProperty.call(n, o) && (a[o] = n[o]);
    return a;
  }
  e.exports = t.default;
})(Rn, Rn.exports);
var Or = Rn.exports;
(function(e, t) {
  var r = cr.default;
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.default = n;
  var a = r(Or);
  function n(o) {
    return (0, a.default)({}, o);
  }
  e.exports = t.default;
})(_n, _n.exports);
var Yr = _n.exports;
const Nr = /* @__PURE__ */ Ln(Yr);
function Ir(e, t, r) {
  var a = Cn(e, r), n = zn(t, a, !0), o = new Date(a.getTime() - n), i = /* @__PURE__ */ new Date(0);
  return i.setFullYear(o.getUTCFullYear(), o.getUTCMonth(), o.getUTCDate()), i.setHours(o.getUTCHours(), o.getUTCMinutes(), o.getUTCSeconds(), o.getUTCMilliseconds()), i;
}
function Br(e, t, r) {
  if (typeof e == "string" && !e.match(Pa)) {
    var a = Nr(r);
    return a.timeZone = t, Cn(e, a);
  }
  var n = Cn(e, r), o = Wn(
    n.getFullYear(),
    n.getMonth(),
    n.getDate(),
    n.getHours(),
    n.getMinutes(),
    n.getSeconds(),
    n.getMilliseconds()
  ).getTime(), i = zn(t, new Date(o));
  return new Date(o + i);
}
function ua(e) {
  return (t) => new Intl.DateTimeFormat(e, { weekday: "short", timeZone: "UTC" }).format(/* @__PURE__ */ new Date(`2017-01-0${t}T00:00:00+00:00`)).slice(0, 2);
}
function Er(e) {
  return (t) => st(/* @__PURE__ */ new Date(`2017-01-0${t}T00:00:00+00:00`), "EEEEEE", { locale: e });
}
const Fr = (e, t, r) => {
  const a = [1, 2, 3, 4, 5, 6, 7];
  let n;
  if (e !== null)
    try {
      n = a.map(Er(e));
    } catch {
      n = a.map(ua(t));
    }
  else
    n = a.map(ua(t));
  const o = n.slice(0, r), i = n.slice(r + 1, n.length);
  return [n[r]].concat(...i).concat(...o);
}, jn = (e, t) => {
  const r = [];
  for (let a = +e[0]; a <= +e[1]; a++)
    r.push({ value: +a, text: `${a}` });
  return t ? r.reverse() : r;
}, _a = (e, t, r) => {
  const a = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12].map((o) => {
    const i = o < 10 ? `0${o}` : o;
    return /* @__PURE__ */ new Date(`2017-${i}-01T00:00:00+00:00`);
  });
  if (e !== null)
    try {
      const o = r === "long" ? "MMMM" : "MMM";
      return a.map((i, d) => {
        const b = st(i, o, { locale: e });
        return {
          text: b.charAt(0).toUpperCase() + b.substring(1),
          value: d
        };
      });
    } catch {
    }
  const n = new Intl.DateTimeFormat(t, { month: r, timeZone: "UTC" });
  return a.map((o, i) => {
    const d = n.format(o);
    return {
      text: d.charAt(0).toUpperCase() + d.substring(1),
      value: i
    };
  });
}, Hr = (e) => [12, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11][e], Se = (e) => {
  const t = c(e);
  return t != null && t.$el ? t == null ? void 0 : t.$el : t;
}, Vr = (e) => Object.assign({ type: "dot" }, e), Ra = (e) => Array.isArray(e) ? !!e[0] && !!e[1] : !1, Qt = {
  prop: (e) => `"${e}" prop must be enabled!`,
  dateArr: (e) => `You need to use array as "model-value" binding in order to support "${e}"`
}, Ae = (e) => e, da = (e) => e === 0 ? e : !e || isNaN(+e) ? null : +e, ca = (e) => e === null, Ur = (e) => {
  if (e)
    return [...e.querySelectorAll("input, button, select, textarea, a[href]")][0];
}, Lr = (e) => {
  const t = [], r = (a) => a.filter((n) => n);
  for (let a = 0; a < e.length; a += 3) {
    const n = [e[a], e[a + 1], e[a + 2]];
    t.push(r(n));
  }
  return t;
}, Bt = (e, t, r) => {
  const a = r ?? r === 0, n = t ?? t === 0;
  if (!a && !n)
    return !1;
  const o = +r, i = +t;
  return a && n ? +e > o || +e < i : a ? +e > o : n ? +e < i : !1;
}, At = (e, t) => Lr(e).map((r) => r.map((a) => {
  const { active: n, disabled: o, isBetween: i, highlighted: d } = t(a);
  return {
    ...a,
    active: n,
    disabled: o,
    className: {
      dp__overlay_cell_active: n,
      dp__overlay_cell: !n,
      dp__overlay_cell_disabled: o,
      dp__overlay_cell_pad: !0,
      dp__overlay_cell_active_disabled: o && n,
      dp__cell_in_between: i,
      "dp--highlighted": d
    }
  };
})), it = (e, t, r = !1) => {
  e && t.allowStopPropagation && (r && e.stopImmediatePropagation(), e.stopPropagation());
}, Wr = (e) => {
  if (e.nextElementSibling)
    return e.nextElementSibling;
  for (; e.parentElement && !e.parentElement.nextElementSibling; )
    e = e.parentElement;
  return e.parentElement ? e.parentElement.nextElementSibling : null;
}, zr = (e) => {
  if (!e)
    return !1;
  const t = [
    "a[href]",
    "area[href]",
    "input:not([disabled]):not([type='hidden'])",
    "select:not([disabled])",
    "textarea:not([disabled])",
    "button:not([disabled])",
    "[tabindex]:not([tabindex='-1'])"
  ], r = e.matches(t.join(", ")), a = e.offsetWidth > 0 || e.offsetHeight > 0 || e.getClientRects().length > 0;
  return r && a;
}, jr = (e) => {
  if (!e)
    return null;
  let t = e;
  for (; t; )
    if (t = Wr(t), zr(t))
      return t;
  return null;
}, fa = (e, t, r, a, n) => {
  const o = Tn(e, t.slice(0, e.length), /* @__PURE__ */ new Date());
  return Gt(o) && tr(o) ? a || n ? o : De(o, {
    hours: +r.hours,
    minutes: +(r == null ? void 0 : r.minutes),
    seconds: +(r == null ? void 0 : r.seconds),
    milliseconds: 0
  }) : null;
}, Kr = (e, t, r, a, n) => {
  const o = Array.isArray(r) ? r[0] : r;
  if (typeof t == "string")
    return fa(e, t, o, a, n);
  if (Array.isArray(t)) {
    let i = null;
    for (const d of t)
      if (i = fa(e, d, o, a, n), i)
        break;
    return i;
  }
  return typeof t == "function" ? t(e) : null;
}, V = (e) => e ? new Date(e) : /* @__PURE__ */ new Date(), Gr = (e, t, r) => {
  if (t) {
    const n = (e.getMonth() + 1).toString().padStart(2, "0"), o = e.getDate().toString().padStart(2, "0"), i = e.getHours().toString().padStart(2, "0"), d = e.getMinutes().toString().padStart(2, "0"), b = r ? e.getSeconds().toString().padStart(2, "0") : "00";
    return `${e.getFullYear()}-${n}-${o}T${i}:${d}:${b}.000Z`;
  }
  const a = Date.UTC(
    e.getUTCFullYear(),
    e.getUTCMonth(),
    e.getUTCDate(),
    e.getUTCHours(),
    e.getUTCMinutes(),
    e.getUTCSeconds()
  );
  return new Date(a).toISOString();
}, He = (e) => {
  let t = V(JSON.parse(JSON.stringify(e)));
  return t = ba(t, 0), t = ka(t, 0), t = In(t, 0), t = Bn(t, 0), t;
}, ut = (e, t, r, a) => {
  let n = e ? V(e) : V();
  return (t || t === 0) && (n = ba(n, +t)), (r || r === 0) && (n = ka(n, +r)), (a || a === 0) && (n = In(n, +a)), Bn(n, 0);
}, _e = (e, t) => !e || !t ? !1 : Yt(He(e), He(t)), pe = (e, t) => !e || !t ? !1 : $t(He(e), He(t)), Ne = (e, t) => !e || !t ? !1 : Nt(He(e), He(t)), Xt = (e, t, r) => e != null && e[0] && (e != null && e[1]) ? Ne(r, e[0]) && _e(r, e[1]) : e != null && e[0] && t ? Ne(r, e[0]) && _e(r, t) || _e(r, e[0]) && Ne(r, t) : !1, Qe = (e) => {
  const t = De(new Date(e), { date: 1 });
  return He(t);
}, yn = (e, t, r) => t && (r || r === 0) ? Object.fromEntries(
  ["hours", "minutes", "seconds"].map((a) => a === t ? [a, r] : [a, isNaN(+e[a]) ? void 0 : +e[a]])
) : {
  hours: isNaN(+e.hours) ? void 0 : +e.hours,
  minutes: isNaN(+e.minutes) ? void 0 : +e.minutes,
  seconds: isNaN(+e.seconds) ? void 0 : +e.seconds
}, pt = (e) => ({
  hours: Je(e),
  minutes: nt(e),
  seconds: Tt(e)
}), Oa = (e, t) => {
  if (t) {
    const r = ce(V(t));
    if (r > e)
      return 12;
    if (r === e)
      return he(V(t));
  }
}, Ya = (e, t) => {
  if (t) {
    const r = ce(V(t));
    return r < e ? -1 : r === e ? he(V(t)) : void 0;
  }
}, St = (e) => {
  if (e)
    return ce(V(e));
}, Le = (e, t) => t ? Ir(e, t) : e, Na = (e, t) => t ? Br(e, t) : e, va = (e) => e instanceof Date ? e : xa(e), Ia = (e, t) => {
  const r = Ne(e, t) ? t : e, a = Ne(t, e) ? t : e;
  return wa({ start: r, end: a });
}, qr = (e) => {
  const t = ht(e, 1);
  return { month: he(t), year: ce(t) };
}, qt = (e, t, r) => {
  const a = Da(Le(e, t), { weekStartsOn: +r }), n = er(Le(e, t), { weekStartsOn: +r });
  return [a, n];
}, Ba = (e, t) => {
  const r = {
    hours: Je(V()),
    minutes: nt(V()),
    seconds: t ? Tt(V()) : 0
  };
  return Object.assign(r, e);
}, ot = (e, t, r) => [De(V(e), { date: 1 }), De(V(), { month: t, year: r, date: 1 })], at = (e, t, r) => {
  let a = e ? V(e) : V();
  return (t || t === 0) && (a = Ja(a, t)), r && (a = tt(a, r)), a;
}, Ea = (e, t, r, a, n) => {
  if (!a || n && !t || !n && !r)
    return !1;
  const o = n ? ht(e, 1) : It(e, 1), i = [he(o), ce(o)];
  return n ? !Qr(...i, t) : !Zr(...i, r);
}, Zr = (e, t, r) => _e(...ot(r, e, t)) || pe(...ot(r, e, t)), Qr = (e, t, r) => Ne(...ot(r, e, t)) || pe(...ot(r, e, t)), Fa = (e, t, r, a, n, o, i) => {
  if (typeof t == "function" && !i)
    return t(e);
  const d = r ? { locale: r } : void 0;
  return Array.isArray(e) ? `${st(e[0], o, d)}${n && !e[1] ? "" : a}${e[1] ? st(e[1], o, d) : ""}` : st(e, o, d);
}, Dt = (e) => {
  if (e)
    return null;
  throw new Error(Qt.prop("partial-range"));
}, Wt = (e, t) => {
  if (t)
    return e();
  throw new Error(Qt.prop("range"));
}, On = (e) => Array.isArray(e) ? Gt(e[0]) && (e[1] ? Gt(e[1]) : !0) : e ? Gt(e) : !1, Xr = (e, t) => De(t ?? V(), {
  hours: +e.hours || 0,
  minutes: +e.minutes || 0,
  seconds: +e.seconds || 0
}), hn = (e, t, r, a) => {
  if (!e)
    return !0;
  if (a) {
    const n = r === "max" ? Yt(e, t) : Nt(e, t), o = { seconds: 0, milliseconds: 0 };
    return n || $t(De(e, o), De(t, o));
  }
  return r === "max" ? e.getTime() <= t.getTime() : e.getTime() >= t.getTime();
}, pn = (e, t, r) => e ? Xr(e, t) : V(r ?? t), ma = (e, t, r, a, n) => {
  if (Array.isArray(a)) {
    const i = pn(e, a[0], t), d = pn(e, a[1], t);
    return hn(a[0], i, r, !!t) && hn(a[1], d, r, !!t) && n;
  }
  const o = pn(e, a, t);
  return hn(a, o, r, !!t) && n;
}, bn = (e) => De(V(), pt(e)), Jr = (e, t) => Array.isArray(e) ? e.map((r) => V(r)).filter((r) => ce(V(r)) === t).map((r) => he(r)) : [], Ha = (e, t, r) => typeof e == "function" ? e({ month: t, year: r }) : !!e.months.find((a) => a.month === t && a.year === r), Kn = (e, t) => typeof e == "function" ? e(t) : e.years.includes(t), Rt = Et({
  menuFocused: !1,
  shiftKeyInMenu: !1
}), Va = () => {
  const e = (a) => {
    Rt.menuFocused = a;
  }, t = (a) => {
    Rt.shiftKeyInMenu !== a && (Rt.shiftKeyInMenu = a);
  };
  return {
    control: Z(() => ({ shiftKeyInMenu: Rt.shiftKeyInMenu, menuFocused: Rt.menuFocused })),
    setMenuFocused: e,
    setShiftKey: t
  };
}, we = Et({
  monthYear: [],
  calendar: [],
  time: [],
  actionRow: [],
  selectionGrid: [],
  timePicker: {
    0: [],
    1: []
  },
  monthPicker: []
}), kn = ee(null), zt = ee(!1), wn = ee(!1), Dn = ee(!1), Mn = ee(!1), Ie = ee(0), Ce = ee(0), ft = () => {
  const e = Z(() => zt.value ? [...we.selectionGrid, we.actionRow].filter((h) => h.length) : wn.value ? [
    ...we.timePicker[0],
    ...we.timePicker[1],
    Mn.value ? [] : [kn.value],
    we.actionRow
  ].filter((h) => h.length) : Dn.value ? [...we.monthPicker, we.actionRow] : [we.monthYear, ...we.calendar, we.time, we.actionRow].filter((h) => h.length)), t = (h) => {
    Ie.value = h ? Ie.value + 1 : Ie.value - 1;
    let _ = null;
    e.value[Ce.value] && (_ = e.value[Ce.value][Ie.value]), _ || (Ie.value = h ? Ie.value - 1 : Ie.value + 1);
  }, r = (h) => {
    if (Ce.value === 0 && !h || Ce.value === e.value.length && h)
      return;
    Ce.value = h ? Ce.value + 1 : Ce.value - 1, e.value[Ce.value] ? e.value[Ce.value] && !e.value[Ce.value][Ie.value] && Ie.value !== 0 && (Ie.value = e.value[Ce.value].length - 1) : Ce.value = h ? Ce.value - 1 : Ce.value + 1;
  }, a = (h) => {
    let _ = null;
    e.value[Ce.value] && (_ = e.value[Ce.value][Ie.value]), _ ? _.focus({ preventScroll: !zt.value }) : Ie.value = h ? Ie.value - 1 : Ie.value + 1;
  }, n = () => {
    t(!0), a(!0);
  }, o = () => {
    t(!1), a(!1);
  }, i = () => {
    r(!1), a(!0);
  }, d = () => {
    r(!0), a(!0);
  }, b = (h, _) => {
    we[_] = h;
  }, P = (h, _) => {
    we[_] = h;
  }, T = () => {
    Ie.value = 0, Ce.value = 0;
  };
  return {
    buildMatrix: b,
    buildMultiLevelMatrix: P,
    setTimePickerBackRef: (h) => {
      kn.value = h;
    },
    setSelectionGrid: (h) => {
      zt.value = h, T(), h || (we.selectionGrid = []);
    },
    setTimePicker: (h, _ = !1) => {
      wn.value = h, Mn.value = _, T(), h || (we.timePicker[0] = [], we.timePicker[1] = []);
    },
    setTimePickerElements: (h, _ = 0) => {
      we.timePicker[_] = h;
    },
    arrowRight: n,
    arrowLeft: o,
    arrowUp: i,
    arrowDown: d,
    clearArrowNav: () => {
      we.monthYear = [], we.calendar = [], we.time = [], we.actionRow = [], we.selectionGrid = [], we.timePicker[0] = [], we.timePicker[1] = [], zt.value = !1, wn.value = !1, Mn.value = !1, Dn.value = !1, T(), kn.value = null;
    },
    setMonthPicker: (h) => {
      Dn.value = h, T();
    },
    refSets: we
    // exposed for testing
  };
}, ga = (e) => ({
  menuAppearTop: "dp-menu-appear-top",
  menuAppearBottom: "dp-menu-appear-bottom",
  open: "dp-slide-down",
  close: "dp-slide-up",
  next: "calendar-next",
  previous: "calendar-prev",
  vNext: "dp-slide-up",
  vPrevious: "dp-slide-down",
  ...e ?? {}
}), xr = (e) => ({
  toggleOverlay: "Toggle overlay",
  menu: "Datepicker menu",
  input: "Datepicker input",
  calendarWrap: "Calendar wrapper",
  calendarDays: "Calendar days",
  openTimePicker: "Open time picker",
  closeTimePicker: "Close time Picker",
  incrementValue: (t) => `Increment ${t}`,
  decrementValue: (t) => `Decrement ${t}`,
  openTpOverlay: (t) => `Open ${t} overlay`,
  amPmButton: "Switch AM/PM mode",
  openYearsOverlay: "Open years overlay",
  openMonthsOverlay: "Open months overlay",
  nextMonth: "Next month",
  prevMonth: "Previous month",
  nextYear: "Next year",
  prevYear: "Previous year",
  day: () => "",
  ...e ?? {}
}), ya = (e) => e ? typeof e == "boolean" ? e ? 2 : 0 : +e >= 2 ? +e : 2 : 0, el = (e) => {
  const t = typeof e == "object" && e, r = {
    static: !0,
    solo: !1
  };
  if (!e)
    return { ...r, count: ya(!1) };
  const a = t ? e : {}, n = t ? a.count ?? !0 : e, o = ya(n);
  return Object.assign(r, a, { count: o });
}, tl = (e, t, r) => e || (typeof r == "string" ? r : t), nl = (e) => typeof e == "boolean" ? e ? ga({}) : !1 : ga(e), al = (e) => {
  const t = {
    enterSubmit: !0,
    tabSubmit: !0,
    openMenu: !0,
    selectOnFocus: !1,
    rangeSeparator: " - "
  };
  return typeof e == "object" ? { ...t, ...e ?? {}, enabled: !0 } : { ...t, enabled: e };
}, rl = (e) => ({
  months: [],
  years: [],
  times: { hours: [], minutes: [], seconds: [] },
  ...e ?? {}
}), ll = (e) => ({
  showSelect: !0,
  showCancel: !0,
  showNow: !1,
  showPreview: !0,
  ...e ?? {}
}), ol = (e) => {
  const t = { input: !1 };
  return typeof e == "object" ? { ...t, ...e ?? {}, enabled: !0 } : {
    enabled: e,
    ...t
  };
}, sl = (e) => ({ ...{
  allowStopPropagation: !0,
  closeOnScroll: !1,
  modeHeight: 255,
  allowPreventDefault: !1,
  closeOnClearValue: !0,
  closeOnAutoApply: !0,
  noSwipe: !1,
  keepActionRow: !1,
  onClickOutside: void 0
}, ...e ?? {} }), il = (e, t, r) => {
  const a = {
    dates: Array.isArray(e) ? e.map((n) => V(n)) : [],
    years: [],
    months: [],
    quarters: [],
    weeks: [],
    weekdays: t,
    options: { highlightDisabled: r }
  };
  return typeof e == "function" ? e : { ...a, ...e ?? {} };
}, Te = (e) => {
  const t = () => {
    const G = e.enableSeconds ? ":ss" : "";
    return e.is24 ? `HH:mm${G}` : `hh:mm${G} aa`;
  }, r = () => e.format ? e.format : e.monthPicker ? "MM/yyyy" : e.timePicker ? t() : e.weekPicker ? "MM/dd/yyyy" : e.yearPicker ? "yyyy" : e.quarterPicker ? "QQQ/yyyy" : e.enableTimePicker ? `MM/dd/yyyy, ${t()}` : "MM/dd/yyyy", a = (G) => Ba(G, e.enableSeconds), n = () => e.range ? e.startTime && Array.isArray(e.startTime) ? [a(e.startTime[0]), a(e.startTime[1])] : null : e.startTime && !Array.isArray(e.startTime) ? a(e.startTime) : null, o = Z(() => el(e.multiCalendars)), i = Z(() => n()), d = Z(() => xr(e.ariaLabels)), b = Z(() => rl(e.filters)), P = Z(() => nl(e.transitions)), T = Z(() => ll(e.actionRow)), p = Z(
    () => tl(e.previewFormat, e.format, r())
  ), U = Z(() => al(e.textInput)), L = Z(() => ol(e.inline)), B = Z(() => sl(e.config)), Y = Z(
    () => il(e.highlight, e.highlightWeekDays, e.highlightDisabledDays)
  );
  return {
    defaultedTransitions: P,
    defaultedMultiCalendars: o,
    defaultedStartTime: i,
    defaultedAriaLabels: d,
    defaultedFilters: b,
    defaultedActionRow: T,
    defaultedPreviewFormat: p,
    defaultedTextInput: U,
    defaultedInline: L,
    defaultedConfig: B,
    defaultedHighlight: Y,
    getDefaultPattern: r,
    getDefaultStartTime: n
  };
}, ul = (e, t, r) => {
  const a = ee(), { defaultedTextInput: n, getDefaultPattern: o } = Te(t), i = ee(""), d = Zt(t, "format");
  dt(a, () => {
    e("internal-model-change", a.value);
  }), dt(d, () => {
    te();
  });
  const b = (s) => Na(s, t.timezone), P = (s) => Le(s, t.timezone), T = (s, D, ie = !1) => Fa(
    s,
    t.format,
    t.formatLocale,
    n.value.rangeSeparator,
    t.modelAuto,
    D ?? o(),
    ie
  ), p = (s) => s ? t.modelType ? y(s) : {
    hours: Je(s),
    minutes: nt(s),
    seconds: t.enableSeconds ? Tt(s) : 0
  } : null, U = (s) => t.modelType ? y(s) : { month: he(s), year: ce(s) }, L = (s) => Array.isArray(s) ? t.multiDates ? s.map((D) => B(D, tt(V(), D))) : Wt(
    () => [
      tt(V(), s[0]),
      s[1] ? tt(V(), s[1]) : Dt(t.partialRange)
    ],
    t.range
  ) : tt(V(), +s), B = (s, D) => (typeof s == "string" || typeof s == "number") && t.modelType ? f(s) : D, Y = (s) => Array.isArray(s) ? [
    B(
      s[0],
      ut(null, +s[0].hours, +s[0].minutes, s[0].seconds)
    ),
    B(
      s[1],
      ut(null, +s[1].hours, +s[1].minutes, s[1].seconds)
    )
  ] : B(s, ut(null, s.hours, s.minutes, s.seconds)), G = (s) => Array.isArray(s) ? t.multiDates ? s.map((D) => B(D, at(null, +D.month, +D.year))) : Wt(
    () => [
      B(s[0], at(null, +s[0].month, +s[0].year)),
      B(
        s[1],
        s[1] ? at(null, +s[1].month, +s[1].year) : Dt(t.partialRange)
      )
    ],
    t.range
  ) : B(s, at(null, +s.month, +s.year)), h = (s) => {
    if (Array.isArray(s))
      return s.map((D) => f(D));
    throw new Error(Qt.dateArr("multi-dates"));
  }, _ = (s) => {
    if (Array.isArray(s))
      return [V(s[0]), V(s[1])];
    throw new Error(Qt.dateArr("week-picker"));
  }, H = (s) => t.modelAuto ? Array.isArray(s) ? [f(s[0]), f(s[1])] : t.autoApply ? [f(s)] : [f(s), null] : Array.isArray(s) ? Wt(
    () => [
      f(s[0]),
      s[1] ? f(s[1]) : Dt(t.partialRange)
    ],
    t.range
  ) : f(s), k = () => {
    Array.isArray(a.value) && t.range && a.value.length === 1 && a.value.push(Dt(t.partialRange));
  }, R = () => {
    const s = a.value;
    return [
      y(s[0]),
      s[1] ? y(s[1]) : Dt(t.partialRange)
    ];
  }, Q = () => a.value[1] ? R() : y(Ae(a.value[0])), q = () => (a.value || []).map((s) => y(s)), x = () => (k(), t.modelAuto ? Q() : t.multiDates ? q() : Array.isArray(a.value) ? Wt(() => R(), t.range) : y(Ae(a.value))), se = (s) => !s || Array.isArray(s) && !s.length ? null : t.timePicker ? Y(Ae(s)) : t.monthPicker ? G(Ae(s)) : t.yearPicker ? L(Ae(s)) : t.multiDates ? h(Ae(s)) : t.weekPicker ? _(Ae(s)) : H(Ae(s)), E = (s) => {
    const D = se(s);
    On(Ae(D)) ? (a.value = Ae(D), te()) : (a.value = null, i.value = "");
  }, m = () => {
    const s = (D) => st(D, n.value.format);
    return `${s(a.value[0])} ${n.value.rangeSeparator} ${a.value[1] ? s(a.value[1]) : ""}`;
  }, $ = () => r.value && a.value ? Array.isArray(a.value) ? m() : st(a.value, n.value.format) : T(a.value), j = () => a.value ? t.multiDates ? a.value.map((s) => T(s)).join("; ") : n.value.enabled && typeof n.value.format == "string" ? $() : T(a.value) : "", te = () => {
    !t.format || typeof t.format == "string" || n.value.enabled && typeof n.value.format == "string" ? i.value = j() : i.value = t.format(a.value);
  }, f = (s) => {
    if (t.utc) {
      const D = new Date(s);
      return t.utc === "preserve" ? new Date(D.getTime() + D.getTimezoneOffset() * 6e4) : D;
    }
    return t.modelType ? t.modelType === "date" || t.modelType === "timestamp" ? P(new Date(s)) : t.modelType === "format" && (typeof t.format == "string" || !t.format) ? Tn(s, o(), /* @__PURE__ */ new Date()) : P(Tn(s, t.modelType, /* @__PURE__ */ new Date())) : P(new Date(s));
  }, y = (s) => s ? t.utc ? Gr(s, t.utc === "preserve", t.enableSeconds) : t.modelType ? t.modelType === "timestamp" ? +b(s) : t.modelType === "format" && (typeof t.format == "string" || !t.format) ? T(b(s)) : T(b(s), t.modelType, !0) : b(s) : "", N = (s, D = !1) => {
    if (e("update:model-value", s), t.emitTimezone && D) {
      const ie = Array.isArray(s) ? s.map((oe) => Le(Ae(oe)), t.emitTimezone) : Le(Ae(s), t.emitTimezone);
      e("update:model-timezone-value", ie);
    }
  }, S = (s) => Array.isArray(a.value) ? t.multiDates ? a.value.map((D) => s(D)) : [
    s(a.value[0]),
    a.value[1] ? s(a.value[1]) : Dt(t.partialRange)
  ] : s(Ae(a.value)), w = (s) => N(Ae(S(s)));
  return {
    inputValue: i,
    internalModelValue: a,
    checkBeforeEmit: () => a.value ? t.range ? t.partialRange ? a.value.length >= 1 : a.value.length === 2 : !!a.value : !1,
    parseExternalModelValue: E,
    formatInputValue: te,
    emitModelValue: () => (te(), t.monthPicker ? w(U) : t.timePicker ? w(p) : t.yearPicker ? w(ce) : t.weekPicker ? N(
      a.value.map((s) => y(s)),
      !0
    ) : N(x(), !0))
  };
}, dl = (e, t) => {
  const { defaultedFilters: r } = Te(e), { validateMonthYearInRange: a } = Ct(e), n = (P, T) => {
    let p = P;
    return r.value.months.includes(he(p)) ? (p = T ? ht(P, 1) : It(P, 1), n(p, T)) : p;
  }, o = (P, T) => {
    let p = P;
    return r.value.years.includes(ce(p)) ? (p = T ? Ma(P, 1) : $a(P, 1), o(p, T)) : p;
  }, i = (P, T = !1) => {
    const p = De(/* @__PURE__ */ new Date(), { month: e.month, year: e.year });
    let U = P ? ht(p, 1) : It(p, 1);
    e.disableYearSelect && (U = tt(U, e.year));
    let L = he(U), B = ce(U);
    r.value.months.includes(L) && (U = n(U, P), L = he(U), B = ce(U)), r.value.years.includes(B) && (U = o(U, P), B = ce(U)), a(L, B, P, e.preventMinMaxNavigation) && d(L, B, T);
  }, d = (P, T, p) => {
    t("update-month-year", { month: P, year: T, fromNav: p });
  }, b = Z(() => (P) => Ea(
    De(/* @__PURE__ */ new Date(), { month: e.month, year: e.year }),
    e.maxDate,
    e.minDate,
    e.preventMinMaxNavigation,
    P
  ));
  return { handleMonthYearChange: i, isDisabled: b, updateMonthYear: d };
};
var Mt = /* @__PURE__ */ ((e) => (e.center = "center", e.left = "left", e.right = "right", e))(Mt || {}), Ze = /* @__PURE__ */ ((e) => (e.month = "month", e.year = "year", e))(Ze || {}), gt = /* @__PURE__ */ ((e) => (e.top = "top", e.bottom = "bottom", e))(gt || {}), bt = /* @__PURE__ */ ((e) => (e.header = "header", e.calendar = "calendar", e.timePicker = "timePicker", e))(bt || {}), et = /* @__PURE__ */ ((e) => (e.month = "month", e.year = "year", e.calendar = "calendar", e.time = "time", e.minutes = "minutes", e.hours = "hours", e.seconds = "seconds", e))(et || {});
const cl = ({
  menuRef: e,
  menuRefInner: t,
  inputRef: r,
  pickerWrapperRef: a,
  inline: n,
  emit: o,
  props: i,
  slots: d
}) => {
  const b = ee({}), P = ee(!1), T = ee({
    top: "0",
    left: "0"
  }), p = ee(!1), U = Zt(i, "teleportCenter");
  dt(U, () => {
    T.value = JSON.parse(JSON.stringify({})), k();
  });
  const L = (y) => {
    if (i.teleport) {
      const N = y.getBoundingClientRect();
      return {
        left: N.left + window.scrollX,
        top: N.top + window.scrollY
      };
    }
    return { top: 0, left: 0 };
  }, B = (y, N) => {
    T.value.left = `${y + N - b.value.width}px`;
  }, Y = (y) => {
    T.value.left = `${y}px`;
  }, G = (y, N) => {
    i.position === Mt.left && Y(y), i.position === Mt.right && B(y, N), i.position === Mt.center && (T.value.left = `${y + N / 2 - b.value.width / 2}px`);
  }, h = (y) => {
    const { width: N, height: S } = y.getBoundingClientRect(), { top: w, left: l } = i.altPosition ? i.altPosition(y) : L(y);
    return { top: +w, left: +l, width: N, height: S };
  }, _ = () => {
    T.value.left = "50%", T.value.top = "50%", T.value.transform = "translate(-50%, -50%)", T.value.position = "fixed", delete T.value.opacity;
  }, H = () => {
    const y = Se(r), { top: N, left: S, transform: w } = i.altPosition(y);
    T.value = { top: `${N}px`, left: `${S}px`, transform: w ?? "" };
  }, k = (y = !0) => {
    var N;
    if (!n.value.enabled) {
      if (U.value)
        return _();
      if (i.altPosition !== null)
        return H();
      if (y) {
        const S = i.teleport ? (N = t.value) == null ? void 0 : N.$el : e.value;
        S && (b.value = S.getBoundingClientRect()), o("recalculate-position");
      }
      return m();
    }
  }, R = ({ inputEl: y, left: N, width: S }) => {
    window.screen.width > 768 && !P.value && G(N, S), x(y);
  }, Q = (y) => {
    const { top: N, left: S, height: w, width: l } = h(y);
    T.value.top = `${w + N + +i.offset}px`, p.value = !1, P.value || (T.value.left = `${S + l / 2 - b.value.width / 2}px`), R({ inputEl: y, left: S, width: l });
  }, q = (y) => {
    const { top: N, left: S, width: w } = h(y);
    T.value.top = `${N - +i.offset - b.value.height}px`, p.value = !0, R({ inputEl: y, left: S, width: w });
  }, x = (y) => {
    if (i.autoPosition) {
      const { left: N, width: S } = h(y), { left: w, right: l } = b.value;
      if (!P.value) {
        if (Math.abs(w) !== Math.abs(l)) {
          if (w <= 0)
            return P.value = !0, Y(N);
          if (l >= document.documentElement.clientWidth)
            return P.value = !0, B(N, S);
        }
        return G(N, S);
      }
    }
  }, se = () => {
    const y = Se(r);
    if (y) {
      const { height: N } = b.value, { top: S, height: w } = y.getBoundingClientRect(), g = window.innerHeight - S - w, s = S;
      return N <= g ? gt.bottom : N > g && N <= s ? gt.top : g >= s ? gt.bottom : gt.top;
    }
    return gt.bottom;
  }, E = (y) => se() === gt.bottom ? Q(y) : q(y), m = () => {
    const y = Se(r);
    if (y)
      return i.autoPosition ? E(y) : Q(y);
  }, $ = function(y) {
    if (y) {
      const N = y.scrollHeight > y.clientHeight, w = window.getComputedStyle(y).overflowY.indexOf("hidden") !== -1;
      return N && !w;
    }
    return !0;
  }, j = function(y) {
    return !y || y === document.body || y.nodeType === Node.DOCUMENT_FRAGMENT_NODE ? window : $(y) ? y : j(y.parentNode);
  }, te = (y) => {
    if (y)
      switch (i.position) {
        case Mt.left:
          return { left: 0, transform: "translateX(0)" };
        case Mt.right:
          return { left: `${y.width}px`, transform: "translateX(-100%)" };
        default:
          return { left: `${y.width / 2}px`, transform: "translateX(-50%)" };
      }
    return {};
  };
  return {
    openOnTop: p,
    menuStyle: T,
    xCorrect: P,
    setMenuPosition: k,
    getScrollableParent: j,
    shadowRender: (y, N) => {
      var ie, oe, u;
      const S = document.createElement("div"), w = (ie = Se(r)) == null ? void 0 : ie.getBoundingClientRect();
      S.setAttribute("id", "dp--temp-container");
      const l = (oe = a.value) != null && oe.clientWidth ? a.value : document.body;
      l.append(S);
      const g = document.getElementById("dp--temp-container"), s = te(w), D = Ga(
        y,
        {
          ...N,
          shadow: !0,
          style: { opacity: 0, position: "absolute", ...s }
        },
        Object.fromEntries(
          Object.keys(d).filter((O) => ["right-sidebar", "left-sidebar"].includes(O)).map((O) => [O, d[O]])
        )
      );
      Qn(D, g), b.value = (u = D.el) == null ? void 0 : u.getBoundingClientRect(), Qn(null, g), l.removeChild(g);
    }
  };
}, lt = [
  { name: "clock-icon", use: ["time", "calendar", "shared"] },
  { name: "arrow-left", use: ["month-year", "calendar", "shared", "year-mode"] },
  { name: "arrow-right", use: ["month-year", "calendar", "shared", "year-mode"] },
  { name: "arrow-up", use: ["time", "calendar", "month-year", "shared"] },
  { name: "arrow-down", use: ["time", "calendar", "month-year", "shared"] },
  { name: "calendar-icon", use: ["month-year", "time", "calendar", "shared", "year-mode"] },
  { name: "day", use: ["calendar", "shared"] },
  { name: "month-overlay-value", use: ["calendar", "month-year", "shared"] },
  { name: "year-overlay-value", use: ["calendar", "month-year", "shared", "year-mode"] },
  { name: "year-overlay", use: ["month-year", "shared"] },
  { name: "month-overlay", use: ["month-year", "shared"] },
  { name: "month-overlay-header", use: ["month-year", "shared"] },
  { name: "year-overlay-header", use: ["month-year", "shared"] },
  { name: "hours-overlay-value", use: ["calendar", "time", "shared"] },
  { name: "minutes-overlay-value", use: ["calendar", "time", "shared"] },
  { name: "seconds-overlay-value", use: ["calendar", "time", "shared"] },
  { name: "hours", use: ["calendar", "time", "shared"] },
  { name: "minutes", use: ["calendar", "time", "shared"] },
  { name: "month", use: ["calendar", "month-year", "shared"] },
  { name: "year", use: ["calendar", "month-year", "shared", "year-mode"] },
  { name: "action-buttons", use: ["action"] },
  { name: "action-preview", use: ["action"] },
  { name: "calendar-header", use: ["calendar", "shared"] },
  { name: "marker-tooltip", use: ["calendar", "shared"] },
  { name: "action-extra", use: ["menu"] },
  { name: "time-picker-overlay", use: ["calendar", "time", "shared"] },
  { name: "am-pm-button", use: ["calendar", "time", "shared"] },
  { name: "left-sidebar", use: ["menu"] },
  { name: "right-sidebar", use: ["menu"] },
  { name: "month-year", use: ["month-year", "shared"] },
  { name: "time-picker", use: ["menu", "shared"] },
  { name: "action-row", use: ["action"] },
  { name: "marker", use: ["calendar", "shared"] },
  { name: "quarter", use: ["shared"] }
], fl = [{ name: "trigger" }, { name: "input-icon" }, { name: "clear-icon" }, { name: "dp-input" }], vl = {
  all: () => lt,
  monthYear: () => lt.filter((e) => e.use.includes("month-year")),
  input: () => fl,
  timePicker: () => lt.filter((e) => e.use.includes("time")),
  action: () => lt.filter((e) => e.use.includes("action")),
  calendar: () => lt.filter((e) => e.use.includes("calendar")),
  menu: () => lt.filter((e) => e.use.includes("menu")),
  shared: () => lt.filter((e) => e.use.includes("shared")),
  yearMode: () => lt.filter((e) => e.use.includes("year-mode"))
}, Ve = (e, t, r) => {
  const a = [];
  return vl[t]().forEach((n) => {
    e[n.name] && a.push(n.name);
  }), r != null && r.length && r.forEach((n) => {
    n.slot && a.push(n.slot);
  }), a;
}, Ht = (e) => {
  const t = Z(() => (a) => e.value ? a ? e.value.open : e.value.close : ""), r = Z(() => (a) => e.value ? a ? e.value.menuAppearTop : e.value.menuAppearBottom : "");
  return { transitionName: t, showTransition: !!e.value, menuTransition: r };
}, Vt = (e, t) => {
  const r = V(Le(/* @__PURE__ */ new Date(), e.timezone)), a = ee([{ month: he(r), year: ce(r) }]), n = Et({
    hours: e.range ? [Je(r), Je(r)] : Je(r),
    minutes: e.range ? [nt(r), nt(r)] : nt(r),
    seconds: e.range ? [0, 0] : 0
  }), o = Z({
    get: () => e.internalModelValue,
    set: (b) => {
      !e.readonly && !e.disabled && t("update:internal-model-value", b);
    }
  }), i = Z(
    () => (b) => a.value[b] ? a.value[b].month : 0
  ), d = Z(
    () => (b) => a.value[b] ? a.value[b].year : 0
  );
  return {
    calendars: a,
    time: n,
    modelValue: o,
    month: i,
    year: d
  };
}, ml = (e, t) => {
  const { defaultedMultiCalendars: r, defaultedHighlight: a } = Te(t), { isDisabled: n, matchDate: o } = Ct(t), i = ee(null), d = ee(V(Le(/* @__PURE__ */ new Date(), t.timezone))), b = (l) => {
    !l.current && t.hideOffsetDates || (i.value = l.value);
  }, P = () => {
    i.value = null;
  }, T = (l) => Array.isArray(e.value) && t.range && e.value[0] && i.value ? l ? Ne(i.value, e.value[0]) : _e(i.value, e.value[0]) : !0, p = (l, g) => {
    const s = () => e.value ? g ? e.value[0] || null : e.value[1] : null, D = e.value && Array.isArray(e.value) ? s() : null;
    return pe(V(l.value), D);
  }, U = (l) => {
    const g = Array.isArray(e.value) ? e.value[0] : null;
    return l ? !_e(i.value ?? null, g) : !0;
  }, L = (l, g = !0) => (t.range || t.weekPicker) && Array.isArray(e.value) && e.value.length === 2 ? t.hideOffsetDates && !l.current ? !1 : pe(V(l.value), e.value[g ? 0 : 1]) : t.range ? p(l, g) && U(g) || pe(l.value, Array.isArray(e.value) ? e.value[0] : null) && T(g) : !1, B = (l, g, s) => Array.isArray(e.value) && e.value[0] && e.value.length === 1 ? l ? !1 : s ? Ne(e.value[0], g.value) : _e(e.value[0], g.value) : !1, Y = (l) => !e.value || t.hideOffsetDates && !l.current ? !1 : t.range ? t.modelAuto && Array.isArray(e.value) ? pe(l.value, e.value[0] ? e.value[0] : d.value) : !1 : t.multiDates && Array.isArray(e.value) ? e.value.some((g) => pe(g, l.value)) : pe(l.value, e.value ? e.value : d.value), G = (l) => {
    if (t.autoRange || t.weekPicker) {
      if (i.value) {
        if (t.hideOffsetDates && !l.current)
          return !1;
        const g = yt(i.value, +t.autoRange), s = qt(V(i.value), t.timezone, t.weekStart);
        return t.weekPicker ? pe(s[1], V(l.value)) : pe(g, V(l.value));
      }
      return !1;
    }
    return !1;
  }, h = (l) => {
    if (t.autoRange || t.weekPicker) {
      if (i.value) {
        const g = yt(i.value, +t.autoRange);
        if (t.hideOffsetDates && !l.current)
          return !1;
        const s = qt(V(i.value), t.timezone, t.weekStart);
        return t.weekPicker ? Ne(l.value, s[0]) && _e(l.value, s[1]) : Ne(l.value, i.value) && _e(l.value, g);
      }
      return !1;
    }
    return !1;
  }, _ = (l) => {
    if (t.autoRange || t.weekPicker) {
      if (i.value) {
        if (t.hideOffsetDates && !l.current)
          return !1;
        const g = qt(V(i.value), t.timezone, t.weekStart);
        return t.weekPicker ? pe(g[0], l.value) : pe(i.value, l.value);
      }
      return !1;
    }
    return !1;
  }, H = (l) => Xt(e.value, i.value, l.value), k = () => t.modelAuto && Array.isArray(t.internalModelValue) ? !!t.internalModelValue[0] : !1, R = () => t.modelAuto ? Ra(t.internalModelValue) : !0, Q = (l) => {
    if (Array.isArray(e.value) && e.value.length || t.weekPicker)
      return !1;
    const g = t.range ? !L(l) && !L(l, !1) : !0;
    return !n(l.value) && !Y(l) && !(!l.current && t.hideOffsetDates) && g;
  }, q = (l) => t.range ? t.modelAuto ? k() && Y(l) : !1 : Y(l), x = (l) => {
    var g;
    return a.value ? typeof a.value == "function" ? a.value(l.value) : o(
      l.value,
      (g = t.arrMapValues) != null && g.highlightedDates ? t.arrMapValues.highlightedDates : a.value.dates
    ) : !1;
  }, se = (l) => {
    const g = n(l.value);
    return g && (typeof a.value == "function" ? !a.value(l.value, g) : !a.value.options.highlightDisabled);
  }, E = (l) => {
    var g;
    return typeof a.value == "function" ? a.value(l.value) : (g = a.value.weekdays) == null ? void 0 : g.includes(l.value.getDay());
  }, m = (l) => (t.range || t.weekPicker) && (!(r.value.count > 0) || l.current) && R() && !(!l.current && t.hideOffsetDates) && !Y(l) ? H(l) : !1, $ = (l) => {
    const { isRangeStart: g, isRangeEnd: s } = f(l), D = t.range ? g || s : !1;
    return {
      dp__cell_offset: !l.current,
      dp__pointer: !t.disabled && !(!l.current && t.hideOffsetDates) && !n(l.value),
      dp__cell_disabled: n(l.value),
      dp__cell_highlight: !se(l) && (x(l) || E(l)) && !q(l) && !D && !_(l) && !(m(l) && t.weekPicker) && !s,
      dp__cell_highlight_active: !se(l) && (x(l) || E(l)) && q(l),
      dp__today: !t.noToday && pe(l.value, d.value) && l.current
    };
  }, j = (l) => ({
    dp__active_date: q(l),
    dp__date_hover: Q(l)
  }), te = (l) => ({
    ...y(l),
    ...N(l),
    dp__range_between_week: m(l) && t.weekPicker
  }), f = (l) => {
    const g = r.value.count > 0 ? l.current && L(l) && R() : L(l) && R(), s = r.value.count > 0 ? l.current && L(l, !1) && R() : L(l, !1) && R();
    return { isRangeStart: g, isRangeEnd: s };
  }, y = (l) => {
    const { isRangeStart: g, isRangeEnd: s } = f(l);
    return {
      dp__range_start: g,
      dp__range_end: s,
      dp__range_between: m(l) && !t.weekPicker,
      dp__date_hover_start: B(Q(l), l, !0),
      dp__date_hover_end: B(Q(l), l, !1)
    };
  }, N = (l) => ({
    ...y(l),
    dp__cell_auto_range: h(l),
    dp__cell_auto_range_start: _(l),
    dp__cell_auto_range_end: G(l)
  }), S = (l) => t.range ? t.autoRange ? N(l) : t.modelAuto ? { ...j(l), ...y(l) } : y(l) : t.weekPicker ? te(l) : j(l);
  return {
    setHoverDate: b,
    clearHoverDate: P,
    getDayClassData: (l) => t.hideOffsetDates && !l.current ? {} : {
      ...$(l),
      ...S(l),
      [t.dayClass ? t.dayClass(l.value) : ""]: !0,
      [t.calendarCellClassName]: !!t.calendarCellClassName
    }
  };
}, Ct = (e) => {
  const { defaultedFilters: t, defaultedHighlight: r } = Te(e), a = () => {
    if (e.timezone)
      return e.timezone;
    if (e.utc)
      return "UTC";
  }, n = (m) => {
    const $ = He(o(V(m))).toISOString(), [j] = $.split("T");
    return j;
  }, o = (m) => e.utc === "preserve" ? Na(m, a()) : Le(m, a()), i = (m) => {
    var g;
    const $ = e.maxDate ? Ne(o(m), o(V(e.maxDate))) : !1, j = e.minDate ? _e(o(m), o(V(e.minDate))) : !1, te = T(
      o(m),
      (g = e.arrMapValues) != null && g.disabledDates ? e.arrMapValues.disabledDates : e.disabledDates
    ), y = t.value.months.map((s) => +s).includes(he(m)), N = e.disabledWeekDays.length ? e.disabledWeekDays.some((s) => +s === nr(m)) : !1, S = U(m), w = ce(m), l = w < +e.yearRange[0] || w > +e.yearRange[1];
    return !($ || j || te || y || l || N || S);
  }, d = (m, $) => _e(...ot(e.minDate, m, $)) || pe(...ot(e.minDate, m, $)), b = (m, $) => Ne(...ot(e.maxDate, m, $)) || pe(...ot(e.maxDate, m, $)), P = (m, $, j) => {
    let te = !1;
    return e.maxDate && j && b(m, $) && (te = !0), e.minDate && !j && d(m, $) && (te = !0), te;
  }, T = (m, $) => m ? $ instanceof Map ? !!$.get(n(m)) : Array.isArray($) ? $.some((j) => pe(o(V(j)), o(m))) : $ ? $(V(JSON.parse(JSON.stringify(m)))) : !1 : !0, p = (m, $, j, te) => {
    let f = !1;
    return te ? e.minDate && e.maxDate ? f = P(m, $, j) : (e.minDate && d(m, $) || e.maxDate && b(m, $)) && (f = !0) : f = !0, f;
  }, U = (m) => {
    var $, j, te, f, y;
    return Array.isArray(e.allowedDates) && !(($ = e.allowedDates) != null && $.length) ? !0 : (j = e.arrMapValues) != null && j.allowedDates ? !T(m, (te = e.arrMapValues) == null ? void 0 : te.allowedDates) : (f = e.allowedDates) != null && f.length ? !((y = e.allowedDates) != null && y.some((N) => pe(o(V(N)), o(m)))) : !1;
  }, L = (m) => !i(m), B = (m) => e.noDisabledRange ? !wa({ start: m[0], end: m[1] }).some((j) => L(j)) : !0, Y = (m, $, j = 0) => {
    if (Array.isArray($) && $[j]) {
      const te = ar(m, $[j]), f = Ia($[j], m), y = f.length === 1 ? 0 : f.filter((S) => L(S)).length, N = Math.abs(te) - y;
      if (e.minRange && e.maxRange)
        return N >= +e.minRange && N <= +e.maxRange;
      if (e.minRange)
        return N >= +e.minRange;
      if (e.maxRange)
        return N <= +e.maxRange;
    }
    return !0;
  }, G = (m) => new Map(m.map(($) => [n($), !0])), h = (m) => Array.isArray(m) && m.length > 0, _ = () => {
    const m = {
      disabledDates: null,
      allowedDates: null,
      highlightedDates: null
    };
    return h(e.allowedDates) && (m.allowedDates = G(e.allowedDates)), typeof r.value != "function" && h(r.value.dates) && (m.highlightedDates = G(r.value.dates)), h(e.disabledDates) && (m.disabledDates = G(e.disabledDates)), m;
  }, H = () => !e.enableTimePicker || e.monthPicker || e.yearPicker || e.ignoreTimeValidation, k = (m) => Array.isArray(m) ? [m[0] ? bn(m[0]) : null, m[1] ? bn(m[1]) : null] : bn(m), R = (m, $, j) => m.find(
    (te) => +te.hours === Je($) && te.minutes === "*" ? !0 : +te.minutes === nt($) && +te.hours === Je($)
  ) && j, Q = (m, $, j) => {
    const [te, f] = m, [y, N] = $;
    return !R(te, y, j) && !R(f, N, j) && j;
  }, q = (m, $) => {
    const j = Array.isArray($) ? $ : [$];
    return Array.isArray(e.disabledTimes) ? Array.isArray(e.disabledTimes[0]) ? Q(e.disabledTimes, j, m) : !j.some((te) => R(e.disabledTimes, te, m)) : m;
  }, x = (m, $) => {
    const j = Array.isArray($) ? [pt($[0]), $[1] ? pt($[1]) : void 0] : pt($), te = !e.disabledTimes(j);
    return m && te;
  }, se = (m, $) => e.disabledTimes ? Array.isArray(e.disabledTimes) ? q($, m) : x($, m) : $;
  return {
    isDisabled: L,
    validateDate: i,
    validateMonthYearInRange: p,
    isDateRangeAllowed: B,
    checkMinMaxRange: Y,
    matchDate: T,
    mapDatesArrToMap: _,
    isValidTime: (m) => {
      let $ = !0;
      if (!m || H())
        return !0;
      const j = !e.minDate && !e.maxDate ? k(m) : m;
      return (e.maxTime || e.maxDate) && ($ = ma(
        e.maxTime,
        e.maxDate,
        "max",
        Ae(j),
        $
      )), (e.minTime || e.minDate) && ($ = ma(
        e.minTime,
        e.minDate,
        "min",
        Ae(j),
        $
      )), se(m, $);
    }
  };
}, Jt = () => {
  const e = Z(() => (a, n) => a == null ? void 0 : a.includes(n)), t = Z(() => (a, n) => a.count ? a.solo ? !0 : n === 0 : !0), r = Z(() => (a, n) => a.count ? a.solo ? !0 : n === a.count - 1 : !0);
  return { hideNavigationButtons: e, showLeftIcon: t, showRightIcon: r };
}, gl = (e, t, r) => {
  const a = ee(0), n = Et({
    [bt.timePicker]: !e.enableTimePicker || e.timePicker || e.monthPicker,
    [bt.calendar]: !1,
    [bt.header]: !1
  }), o = (...T) => {
    var p;
    (p = e.flow) != null && p.length && (n[T] = !0, Object.keys(n).filter((U) => !n[U]).length || P());
  }, i = () => {
    var T;
    (T = e.flow) != null && T.length && a.value !== -1 && (a.value += 1, t("flow-step", a.value), P());
  }, d = () => {
    a.value = -1;
  }, b = (T, p, ...U) => {
    e.flow[a.value] === T && r.value && r.value[p](...U);
  }, P = () => {
    b(et.month, "toggleMonthPicker", !0), b(et.year, "toggleYearPicker", !0), b(et.calendar, "toggleTimePicker", !1, !0), b(et.time, "toggleTimePicker", !0, !0);
    const T = e.flow[a.value];
    (T === et.hours || T === et.minutes || T === et.seconds) && b(T, "toggleTimePicker", !0, !0, T);
  };
  return { childMount: o, updateFlowStep: i, resetFlow: d, flowStep: a };
}, xt = {
  multiCalendars: { type: [Boolean, Number, String, Object], default: void 0 },
  modelValue: { type: [String, Date, Array, Object, Number], default: null },
  modelType: { type: String, default: null },
  position: { type: String, default: "center" },
  dark: { type: Boolean, default: !1 },
  format: {
    type: [String, Function],
    default: () => null
  },
  autoPosition: { type: Boolean, default: !0 },
  altPosition: { type: Function, default: null },
  transitions: { type: [Boolean, Object], default: !0 },
  formatLocale: { type: Object, default: null },
  utc: { type: [Boolean, String], default: !1 },
  ariaLabels: { type: Object, default: () => ({}) },
  offset: { type: [Number, String], default: 10 },
  hideNavigation: { type: Array, default: () => [] },
  timezone: { type: String, default: null },
  emitTimezone: { type: String, default: null },
  vertical: { type: Boolean, default: !1 },
  disableMonthYearSelect: { type: Boolean, default: !1 },
  disableYearSelect: { type: Boolean, default: !1 },
  menuClassName: { type: String, default: null },
  dayClass: { type: Function, default: null },
  yearRange: { type: Array, default: () => [1900, 2100] },
  calendarCellClassName: { type: String, default: null },
  enableTimePicker: { type: Boolean, default: !0 },
  autoApply: { type: Boolean, default: !1 },
  disabledDates: { type: [Array, Function], default: () => [] },
  monthNameFormat: { type: String, default: "short" },
  startDate: { type: [Date, String], default: null },
  startTime: { type: [Object, Array], default: null },
  hideOffsetDates: { type: Boolean, default: !1 },
  autoRange: { type: [Number, String], default: null },
  noToday: { type: Boolean, default: !1 },
  disabledWeekDays: { type: Array, default: () => [] },
  allowedDates: { type: Array, default: null },
  nowButtonLabel: { type: String, default: "Now" },
  markers: { type: Array, default: () => [] },
  escClose: { type: Boolean, default: !0 },
  spaceConfirm: { type: Boolean, default: !0 },
  monthChangeOnArrows: { type: Boolean, default: !0 },
  presetDates: { type: Array, default: () => [] },
  flow: { type: Array, default: () => [] },
  partialFlow: { type: Boolean, default: !1 },
  preventMinMaxNavigation: { type: Boolean, default: !1 },
  minRange: { type: [Number, String], default: null },
  maxRange: { type: [Number, String], default: null },
  multiDatesLimit: { type: [Number, String], default: null },
  reverseYears: { type: Boolean, default: !1 },
  weekPicker: { type: Boolean, default: !1 },
  filters: { type: Object, default: () => ({}) },
  arrowNavigation: { type: Boolean, default: !1 },
  disableTimeRangeValidation: { type: Boolean, default: !1 },
  highlight: {
    type: [Array, Function, Object],
    default: null
  },
  highlightWeekDays: {
    type: Array,
    default: null
  },
  highlightDisabledDays: { type: Boolean, default: !1 },
  teleport: { type: [String, Boolean, Object], default: null },
  teleportCenter: { type: Boolean, default: !1 },
  locale: { type: String, default: "en-Us" },
  weekNumName: { type: String, default: "W" },
  weekStart: { type: [Number, String], default: 1 },
  weekNumbers: {
    type: [String, Function],
    default: null
  },
  calendarClassName: { type: String, default: null },
  monthChangeOnScroll: { type: [Boolean, String], default: !0 },
  dayNames: {
    type: [Function, Array],
    default: null
  },
  monthPicker: { type: Boolean, default: !1 },
  customProps: { type: Object, default: null },
  yearPicker: { type: Boolean, default: !1 },
  modelAuto: { type: Boolean, default: !1 },
  selectText: { type: String, default: "Select" },
  cancelText: { type: String, default: "Cancel" },
  previewFormat: {
    type: [String, Function],
    default: () => ""
  },
  multiDates: { type: Boolean, default: !1 },
  partialRange: { type: Boolean, default: !0 },
  ignoreTimeValidation: { type: Boolean, default: !1 },
  minDate: { type: [Date, String], default: null },
  maxDate: { type: [Date, String], default: null },
  minTime: { type: Object, default: null },
  maxTime: { type: Object, default: null },
  name: { type: String, default: null },
  placeholder: { type: String, default: "" },
  hideInputIcon: { type: Boolean, default: !1 },
  clearable: { type: Boolean, default: !0 },
  state: { type: Boolean, default: null },
  required: { type: Boolean, default: !1 },
  autocomplete: { type: String, default: "off" },
  inputClassName: { type: String, default: null },
  fixedStart: { type: Boolean, default: !1 },
  fixedEnd: { type: Boolean, default: !1 },
  timePicker: { type: Boolean, default: !1 },
  enableSeconds: { type: Boolean, default: !1 },
  is24: { type: Boolean, default: !0 },
  noHoursOverlay: { type: Boolean, default: !1 },
  noMinutesOverlay: { type: Boolean, default: !1 },
  noSecondsOverlay: { type: Boolean, default: !1 },
  hoursGridIncrement: { type: [String, Number], default: 1 },
  minutesGridIncrement: { type: [String, Number], default: 5 },
  secondsGridIncrement: { type: [String, Number], default: 5 },
  hoursIncrement: { type: [Number, String], default: 1 },
  minutesIncrement: { type: [Number, String], default: 1 },
  secondsIncrement: { type: [Number, String], default: 1 },
  range: { type: Boolean, default: !1 },
  uid: { type: String, default: null },
  disabled: { type: Boolean, default: !1 },
  readonly: { type: Boolean, default: !1 },
  inline: { type: [Boolean, Object], default: !1 },
  textInput: { type: [Boolean, Object], default: !1 },
  noDisabledRange: { type: Boolean, default: !1 },
  sixWeeks: { type: [Boolean, String], default: !1 },
  actionRow: { type: Object, default: () => ({}) },
  focusStartDate: { type: Boolean, default: !1 },
  disabledTimes: { type: [Function, Array], default: void 0 },
  showLastInRange: { type: Boolean, default: !0 },
  timePickerInline: { type: Boolean, default: !1 },
  calendar: { type: Function, default: null },
  config: { type: Object, default: void 0 },
  quarterPicker: { type: Boolean, default: !1 },
  yearFirst: { type: Boolean, default: !1 }
}, xe = {
  ...xt,
  shadow: { type: Boolean, default: !1 },
  flowStep: { type: Number, default: 0 },
  internalModelValue: { type: [Date, Array], default: null },
  arrMapValues: { type: Object, default: () => ({}) },
  noOverlayFocus: { type: Boolean, default: !1 }
}, yl = {
  key: 1,
  class: "dp__input_wrap"
}, hl = ["id", "name", "inputmode", "placeholder", "disabled", "readonly", "required", "value", "autocomplete", "aria-label", "aria-disabled", "aria-invalid", "onKeydown"], pl = {
  key: 2,
  class: "dp__clear_icon"
}, bl = /* @__PURE__ */ Oe({
  compatConfig: {
    MODE: 3
  },
  __name: "DatepickerInput",
  props: {
    isMenuOpen: { type: Boolean, default: !1 },
    inputValue: { type: String, default: "" },
    ...xt
  },
  emits: [
    "clear",
    "open",
    "update:input-value",
    "set-input-date",
    "close",
    "select-date",
    "set-empty-date",
    "toggle",
    "focus-prev",
    "focus",
    "blur",
    "real-blur"
  ],
  setup(e, { expose: t, emit: r }) {
    const a = r, n = e, {
      defaultedTextInput: o,
      defaultedAriaLabels: i,
      defaultedInline: d,
      defaultedConfig: b,
      getDefaultPattern: P,
      getDefaultStartTime: T
    } = Te(n), p = ee(), U = ee(null), L = ee(!1), B = ee(!1), Y = Z(
      () => ({
        dp__pointer: !n.disabled && !n.readonly && !o.value.enabled,
        dp__disabled: n.disabled,
        dp__input_readonly: !o.value.enabled,
        dp__input: !0,
        dp__input_icon_pad: !n.hideInputIcon,
        dp__input_valid: !!n.state,
        dp__input_invalid: n.state === !1,
        dp__input_focus: L.value || n.isMenuOpen,
        dp__input_reg: !o.value.enabled,
        [n.inputClassName]: !!n.inputClassName
      })
    ), G = () => {
      a("set-input-date", null), n.autoApply && (a("set-empty-date"), p.value = null);
    }, h = (f) => {
      const y = T();
      return Kr(
        f,
        o.value.format ?? P(),
        y ?? Ba({}, n.enableSeconds),
        n.inputValue,
        B.value
      );
    }, _ = (f) => {
      const { rangeSeparator: y } = o.value, [N, S] = f.split(`${y}`);
      if (N) {
        const w = h(N.trim()), l = S ? h(S.trim()) : null, g = w && l ? [w, l] : [w];
        p.value = w ? g : null;
      }
    }, H = () => {
      B.value = !0;
    }, k = (f) => {
      if (n.range)
        _(f);
      else if (n.multiDates) {
        const y = f.split(";");
        p.value = y.map((N) => h(N.trim())).filter((N) => N);
      } else
        p.value = h(f);
    }, R = (f) => {
      var N;
      const y = typeof f == "string" ? f : (N = f.target) == null ? void 0 : N.value;
      y !== "" ? (o.value.openMenu && !n.isMenuOpen && a("open"), k(y), a("set-input-date", p.value)) : G(), B.value = !1, a("update:input-value", y);
    }, Q = (f) => {
      o.value.enabled ? (k(f.target.value), o.value.enterSubmit && On(p.value) && n.inputValue !== "" ? (a("set-input-date", p.value, !0), p.value = null) : o.value.enterSubmit && n.inputValue === "" && (p.value = null, a("clear"))) : se(f);
    }, q = (f) => {
      o.value.enabled && o.value.tabSubmit && k(f.target.value), o.value.tabSubmit && On(p.value) && n.inputValue !== "" ? (a("set-input-date", p.value, !0, !0), p.value = null) : o.value.tabSubmit && n.inputValue === "" && (p.value = null, a("clear", !0));
    }, x = () => {
      var f;
      L.value = !0, a("focus"), o.value.enabled && o.value.selectOnFocus && ((f = U.value) == null || f.select());
    }, se = (f) => {
      f.preventDefault(), it(f, b.value, !0), o.value.enabled && o.value.openMenu && !d.value.input && !n.isMenuOpen ? a("open") : o.value.enabled || a("toggle");
    }, E = () => {
      a("real-blur"), L.value = !1, (!n.isMenuOpen || d.value.enabled && d.value.input) && a("blur"), n.autoApply && o.value.enabled && p.value && !n.isMenuOpen && (a("set-input-date", p.value), a("select-date"), p.value = null);
    }, m = (f) => {
      it(f, b.value, !0), a("clear");
    }, $ = (f) => {
      if (!o.value.enabled) {
        if (f.code === "Tab")
          return;
        f.preventDefault();
      }
    };
    return t({
      focusInput: () => {
        var f;
        (f = U.value) == null || f.focus({ preventScroll: !0 });
      },
      setParsedDate: (f) => {
        p.value = f;
      }
    }), (f, y) => {
      var N;
      return M(), W("div", { onClick: se }, [
        f.$slots.trigger && !f.$slots["dp-input"] && !c(d).enabled ? le(f.$slots, "trigger", { key: 0 }) : K("", !0),
        !f.$slots.trigger && (!c(d).enabled || c(d).input) ? (M(), W("div", yl, [
          f.$slots["dp-input"] && !f.$slots.trigger && !c(d).enabled ? le(f.$slots, "dp-input", {
            key: 0,
            value: e.inputValue,
            isMenuOpen: e.isMenuOpen,
            onInput: R,
            onEnter: Q,
            onTab: q,
            onClear: m,
            onBlur: E,
            onKeypress: $,
            onPaste: H
          }) : K("", !0),
          f.$slots["dp-input"] ? K("", !0) : (M(), W("input", {
            key: 1,
            id: f.uid ? `dp-input-${f.uid}` : void 0,
            ref_key: "inputRef",
            ref: U,
            name: f.name,
            class: be(Y.value),
            inputmode: c(o).enabled ? "text" : "none",
            placeholder: f.placeholder,
            disabled: f.disabled,
            readonly: f.readonly,
            required: f.required,
            value: e.inputValue,
            autocomplete: f.autocomplete,
            "aria-label": (N = c(i)) == null ? void 0 : N.input,
            "aria-disabled": f.disabled || void 0,
            "aria-invalid": f.state === !1 ? !0 : void 0,
            onInput: R,
            onKeydown: [
              ue(Q, ["enter"]),
              ue(q, ["tab"]),
              $
            ],
            onBlur: E,
            onFocus: x,
            onKeypress: $,
            onPaste: H
          }, null, 42, hl)),
          de("div", {
            onClick: y[2] || (y[2] = (S) => a("toggle"))
          }, [
            f.$slots["input-icon"] && !f.hideInputIcon ? (M(), W("span", {
              key: 0,
              class: "dp__input_icon",
              onClick: y[0] || (y[0] = (S) => a("toggle"))
            }, [
              le(f.$slots, "input-icon")
            ])) : K("", !0),
            !f.$slots["input-icon"] && !f.hideInputIcon && !f.$slots["dp-input"] ? (M(), ge(c(Ft), {
              key: 1,
              class: "dp__input_icon dp__input_icons",
              onClick: y[1] || (y[1] = (S) => a("toggle"))
            })) : K("", !0)
          ]),
          f.$slots["clear-icon"] && e.inputValue && f.clearable && !f.disabled && !f.readonly ? (M(), W("span", pl, [
            le(f.$slots, "clear-icon", { clear: m })
          ])) : K("", !0),
          f.clearable && !f.$slots["clear-icon"] && e.inputValue && !f.disabled && !f.readonly ? (M(), ge(c(Aa), {
            key: 3,
            class: "dp__clear_icon dp__input_icons",
            onClick: y[3] || (y[3] = ke((S) => m(S), ["prevent"]))
          })) : K("", !0)
        ])) : K("", !0)
      ]);
    };
  }
}), kl = ["title"], wl = { class: "dp__action_buttons" }, Dl = ["disabled", "onKeydown"], Ml = /* @__PURE__ */ Oe({
  compatConfig: {
    MODE: 3
  },
  __name: "ActionRow",
  props: {
    menuMount: { type: Boolean, default: !1 },
    calendarWidth: { type: Number, default: 0 },
    ...xe
  },
  emits: ["close-picker", "select-date", "select-now", "invalid-select"],
  setup(e, { emit: t }) {
    const r = t, a = e, {
      defaultedActionRow: n,
      defaultedPreviewFormat: o,
      defaultedMultiCalendars: i,
      defaultedTextInput: d,
      defaultedInline: b,
      getDefaultPattern: P
    } = Te(a), { isValidTime: T } = Ct(a), { buildMatrix: p } = ft(), U = ee(null), L = ee(null);
    ze(() => {
      a.arrowNavigation && p([Se(U), Se(L)], "actionRow");
    });
    const B = Z(() => a.range && !a.partialRange && a.internalModelValue ? a.internalModelValue.length === 2 : !0), Y = Z(() => !G.value || !h.value || !B.value), G = Z(() => !a.enableTimePicker || a.ignoreTimeValidation ? !0 : T(a.internalModelValue)), h = Z(() => a.monthPicker ? a.range && Array.isArray(a.internalModelValue) ? !a.internalModelValue.filter((m) => !x(m)).length : x(a.internalModelValue) : !0), _ = () => {
      const E = o.value;
      return a.timePicker || a.monthPicker, E(Ae(a.internalModelValue));
    }, H = () => {
      const E = a.internalModelValue;
      return i.value.count > 0 ? `${k(E[0])} - ${k(E[1])}` : [k(E[0]), k(E[1])];
    }, k = (E) => Fa(
      E,
      o.value,
      a.formatLocale,
      d.value.rangeSeparator,
      a.modelAuto,
      P()
    ), R = Z(() => !a.internalModelValue || !a.menuMount ? "" : typeof o.value == "string" ? Array.isArray(a.internalModelValue) ? a.internalModelValue.length === 2 && a.internalModelValue[1] ? H() : a.multiDates ? a.internalModelValue.map((E) => `${k(E)}`) : a.modelAuto ? `${k(a.internalModelValue[0])}` : `${k(a.internalModelValue[0])} -` : k(a.internalModelValue) : _()), Q = () => a.multiDates ? "; " : " - ", q = Z(
      () => Array.isArray(R.value) ? R.value.join(Q()) : R.value
    ), x = (E) => {
      if (!a.monthPicker)
        return !0;
      let m = !0;
      const $ = V(Qe(E));
      if (a.minDate && a.maxDate) {
        const j = V(Qe(a.minDate)), te = V(Qe(a.maxDate));
        return Ne($, j) && _e($, te) || pe($, j) || pe($, te);
      }
      if (a.minDate) {
        const j = V(Qe(a.minDate));
        m = Ne($, j) || pe($, j);
      }
      if (a.maxDate) {
        const j = V(Qe(a.maxDate));
        m = _e($, j) || pe($, j);
      }
      return m;
    }, se = () => {
      G.value && h.value && B.value ? r("select-date") : r("invalid-select");
    };
    return (E, m) => (M(), W("div", {
      class: "dp__action_row",
      style: Xe(e.calendarWidth ? { width: `${e.calendarWidth}px` } : {})
    }, [
      E.$slots["action-row"] ? le(E.$slots, "action-row", Pe(Re({ key: 0 }, {
        internalModelValue: E.internalModelValue,
        disabled: Y.value,
        selectDate: () => E.$emit("select-date"),
        closePicker: () => E.$emit("close-picker")
      }))) : (M(), W(ve, { key: 1 }, [
        c(n).showPreview ? (M(), W("div", {
          key: 0,
          class: "dp__selection_preview",
          title: q.value
        }, [
          E.$slots["action-preview"] ? le(E.$slots, "action-preview", {
            key: 0,
            value: E.internalModelValue
          }) : K("", !0),
          E.$slots["action-preview"] ? K("", !0) : (M(), W(ve, { key: 1 }, [
            rt(Ye(q.value), 1)
          ], 64))
        ], 8, kl)) : K("", !0),
        de("div", wl, [
          E.$slots["action-buttons"] ? le(E.$slots, "action-buttons", {
            key: 0,
            value: E.internalModelValue
          }) : K("", !0),
          E.$slots["action-buttons"] ? K("", !0) : (M(), W(ve, { key: 1 }, [
            !c(b).enabled && c(n).showCancel ? (M(), W("button", {
              key: 0,
              ref_key: "cancelButtonRef",
              ref: U,
              type: "button",
              class: "dp__action_button dp__action_cancel",
              onClick: m[0] || (m[0] = ($) => E.$emit("close-picker")),
              onKeydown: [
                m[1] || (m[1] = ue(($) => E.$emit("close-picker"), ["enter"])),
                m[2] || (m[2] = ue(($) => E.$emit("close-picker"), ["space"]))
              ]
            }, Ye(E.cancelText), 545)) : K("", !0),
            c(n).showNow ? (M(), W("button", {
              key: 1,
              ref_key: "cancelButtonRef",
              ref: U,
              type: "button",
              class: "dp__action_button dp__action_cancel",
              onClick: m[3] || (m[3] = ($) => E.$emit("select-now")),
              onKeydown: [
                m[4] || (m[4] = ue(($) => E.$emit("select-now"), ["enter"])),
                m[5] || (m[5] = ue(($) => E.$emit("select-now"), ["space"]))
              ]
            }, Ye(E.nowButtonLabel), 545)) : K("", !0),
            c(n).showSelect ? (M(), W("button", {
              key: 2,
              ref_key: "selectButtonRef",
              ref: L,
              type: "button",
              class: "dp__action_button dp__action_select",
              disabled: Y.value,
              onKeydown: [
                ue(se, ["enter"]),
                ue(se, ["space"])
              ],
              onClick: se
            }, Ye(E.selectText), 41, Dl)) : K("", !0)
          ], 64))
        ])
      ], 64))
    ], 4));
  }
}), $l = ["onKeydown"], Tl = { class: "dp__selection_grid_header" }, Al = ["aria-selected", "aria-disabled", "onClick", "onKeydown", "onMouseover"], Sl = ["aria-label", "onKeydown"], Ut = /* @__PURE__ */ Oe({
  __name: "SelectionOverlay",
  props: {
    items: {},
    type: {},
    isLast: { type: Boolean },
    arrowNavigation: { type: Boolean },
    skipButtonRef: { type: Boolean },
    headerRefs: {},
    hideNavigation: {},
    escClose: { type: Boolean },
    useRelative: { type: Boolean },
    height: {},
    textInput: { type: [Boolean, Object] },
    config: {},
    noOverlayFocus: { type: Boolean }
  },
  emits: ["selected", "toggle", "reset-flow", "hover-value"],
  setup(e, { expose: t, emit: r }) {
    const { setSelectionGrid: a, buildMultiLevelMatrix: n, setMonthPicker: o } = ft(), i = r, d = e, { defaultedAriaLabels: b, defaultedTextInput: P, defaultedConfig: T } = Te(
      d
    ), { hideNavigationButtons: p } = Jt(), U = ee(!1), L = ee(null), B = ee(null), Y = ee([]), G = ee(), h = ee(null), _ = ee(0), H = ee(null);
    qa(() => {
      L.value = null;
    }), ze(() => {
      ct().then(() => m()), d.noOverlayFocus || R(), k(!0);
    }), Yn(() => k(!1));
    const k = (w) => {
      var l;
      d.arrowNavigation && ((l = d.headerRefs) != null && l.length ? o(w) : a(w));
    }, R = () => {
      var l;
      const w = Se(B);
      w && (P.value.enabled || (L.value ? (l = L.value) == null || l.focus({ preventScroll: !0 }) : w.focus({ preventScroll: !0 })), U.value = w.clientHeight < w.scrollHeight);
    }, Q = Z(
      () => ({
        dp__overlay: !0,
        "dp--overlay-absolute": !d.useRelative,
        "dp--overlay-relative": d.useRelative
      })
    ), q = Z(
      () => d.useRelative ? { height: `${d.height}px`, width: "260px" } : void 0
    ), x = Z(() => ({
      dp__overlay_col: !0
    })), se = Z(
      () => ({
        dp__btn: !0,
        dp__button: !0,
        dp__overlay_action: !0,
        dp__over_action_scroll: U.value,
        dp__button_bottom: d.isLast
      })
    ), E = Z(() => {
      var w, l;
      return {
        dp__overlay_container: !0,
        dp__container_flex: ((w = d.items) == null ? void 0 : w.length) <= 6,
        dp__container_block: ((l = d.items) == null ? void 0 : l.length) > 6
      };
    });
    dt(
      () => d.items,
      () => m(),
      { deep: !0 }
    );
    const m = () => {
      ct().then(() => {
        const w = Se(L), l = Se(B), g = Se(h), s = Se(H), D = g ? g.getBoundingClientRect().height : 0;
        l && (l.getBoundingClientRect().height ? _.value = l.getBoundingClientRect().height - D : _.value = T.value.modeHeight - D), w && s && (s.scrollTop = w.offsetTop - s.offsetTop - (_.value / 2 - w.getBoundingClientRect().height) - D);
      });
    }, $ = (w) => {
      w.disabled || i("selected", w.value);
    }, j = () => {
      i("toggle"), i("reset-flow");
    }, te = () => {
      d.escClose && j();
    }, f = (w, l, g, s) => {
      w && (l.active && (L.value = w), d.arrowNavigation && (Array.isArray(Y.value[g]) ? Y.value[g][s] = w : Y.value[g] = [w], y()));
    }, y = () => {
      var l, g;
      const w = (l = d.headerRefs) != null && l.length ? [d.headerRefs].concat(Y.value) : Y.value.concat([d.skipButtonRef ? [] : [h.value]]);
      n(Ae(w), (g = d.headerRefs) != null && g.length ? "monthPicker" : "selectionGrid");
    }, N = (w) => {
      d.arrowNavigation || it(w, T.value, !0);
    }, S = (w) => {
      G.value = w, i("hover-value", w);
    };
    return t({ focusGrid: R }), (w, l) => {
      var g;
      return M(), W("div", {
        ref_key: "gridWrapRef",
        ref: B,
        class: be(Q.value),
        style: Xe(q.value),
        role: "dialog",
        tabindex: "0",
        onKeydown: [
          ue(ke(te, ["prevent"]), ["esc"]),
          l[0] || (l[0] = ue(ke((s) => N(s), ["prevent"]), ["left"])),
          l[1] || (l[1] = ue(ke((s) => N(s), ["prevent"]), ["up"])),
          l[2] || (l[2] = ue(ke((s) => N(s), ["prevent"]), ["down"])),
          l[3] || (l[3] = ue(ke((s) => N(s), ["prevent"]), ["right"]))
        ]
      }, [
        de("div", {
          ref_key: "containerRef",
          ref: H,
          class: be(E.value),
          role: "grid",
          style: Xe({ height: `${_.value}px` })
        }, [
          de("div", Tl, [
            le(w.$slots, "header")
          ]),
          w.$slots.overlay ? le(w.$slots, "overlay", { key: 0 }) : (M(!0), W(ve, { key: 1 }, Me(w.items, (s, D) => (M(), W("div", {
            key: D,
            class: be(["dp__overlay_row", { dp__flex_row: w.items.length >= 3 }]),
            role: "row"
          }, [
            (M(!0), W(ve, null, Me(s, (ie, oe) => (M(), W("div", {
              key: ie.value,
              ref_for: !0,
              ref: (u) => f(u, ie, D, oe),
              role: "gridcell",
              class: be(x.value),
              "aria-selected": ie.active,
              "aria-disabled": ie.disabled || void 0,
              tabindex: "0",
              onClick: (u) => $(ie),
              onKeydown: [
                ue(ke((u) => $(ie), ["prevent"]), ["enter"]),
                ue(ke((u) => $(ie), ["prevent"]), ["space"])
              ],
              onMouseover: (u) => S(ie.value)
            }, [
              de("div", {
                class: be(ie.className)
              }, [
                w.$slots.item ? le(w.$slots, "item", {
                  key: 0,
                  item: ie
                }) : K("", !0),
                w.$slots.item ? K("", !0) : (M(), W(ve, { key: 1 }, [
                  rt(Ye(ie.text), 1)
                ], 64))
              ], 2)
            ], 42, Al))), 128))
          ], 2))), 128))
        ], 6),
        w.$slots["button-icon"] ? jt((M(), W("button", {
          key: 0,
          ref_key: "toggleButton",
          ref: h,
          type: "button",
          "aria-label": (g = c(b)) == null ? void 0 : g.toggleOverlay,
          class: be(se.value),
          tabindex: "0",
          onClick: j,
          onKeydown: [
            ue(j, ["enter"]),
            ue(j, ["tab"])
          ]
        }, [
          le(w.$slots, "button-icon")
        ], 42, Sl)), [
          [Kt, !c(p)(w.hideNavigation, w.type)]
        ]) : K("", !0)
      ], 46, $l);
    };
  }
}), en = /* @__PURE__ */ Oe({
  __name: "InstanceWrap",
  props: {
    multiCalendars: {},
    stretch: { type: Boolean }
  },
  setup(e) {
    const t = e, r = Z(
      () => t.multiCalendars > 0 ? [...Array(t.multiCalendars).keys()] : [0]
    ), a = Z(() => ({
      dp__instance_calendar: t.multiCalendars > 0
    }));
    return (n, o) => (M(), W("div", {
      class: be({
        dp__menu_inner: !n.stretch,
        "dp--menu--inner-stretched": n.stretch,
        dp__flex_display: n.multiCalendars > 0
      })
    }, [
      (M(!0), W(ve, null, Me(r.value, (i, d) => (M(), W("div", {
        key: i,
        class: be(a.value)
      }, [
        le(n.$slots, "default", {
          instance: i,
          index: d
        })
      ], 2))), 128))
    ], 2));
  }
}), Pl = ["aria-label", "aria-disabled"], Ot = /* @__PURE__ */ Oe({
  compatConfig: {
    MODE: 3
  },
  __name: "ArrowBtn",
  props: {
    ariaLabel: {},
    disabled: { type: Boolean }
  },
  emits: ["activate", "set-ref"],
  setup(e, { emit: t }) {
    const r = t, a = ee(null);
    return ze(() => r("set-ref", a)), (n, o) => (M(), W("button", {
      ref_key: "elRef",
      ref: a,
      type: "button",
      class: "dp__btn dp--arrow-btn-nav",
      tabindex: "0",
      "aria-label": n.ariaLabel,
      "aria-disabled": n.disabled || void 0,
      onClick: o[0] || (o[0] = (i) => n.$emit("activate")),
      onKeydown: [
        o[1] || (o[1] = ue(ke((i) => n.$emit("activate"), ["prevent"]), ["enter"])),
        o[2] || (o[2] = ue(ke((i) => n.$emit("activate"), ["prevent"]), ["space"]))
      ]
    }, [
      de("span", {
        class: be(["dp__inner_nav", { dp__inner_nav_disabled: n.disabled }])
      }, [
        le(n.$slots, "default")
      ], 2)
    ], 40, Pl));
  }
}), Cl = { class: "dp--year-mode-picker" }, _l = ["aria-label"], Ua = /* @__PURE__ */ Oe({
  __name: "YearModePicker",
  props: {
    ...xe,
    showYearPicker: { type: Boolean, default: !1 },
    items: { type: Array, default: () => [] },
    instance: { type: Number, default: 0 },
    year: { type: Number, default: 0 },
    isDisabled: { type: Function, default: () => !1 }
  },
  emits: ["toggle-year-picker", "year-select", "handle-year"],
  setup(e, { emit: t }) {
    const r = t, a = e, { showRightIcon: n, showLeftIcon: o } = Jt(), { defaultedConfig: i, defaultedMultiCalendars: d, defaultedAriaLabels: b, defaultedTransitions: P } = Te(a), { showTransition: T, transitionName: p } = Ht(P), U = (Y = !1, G) => {
      r("toggle-year-picker", { flow: Y, show: G });
    }, L = (Y) => {
      r("year-select", Y);
    }, B = (Y = !1) => {
      r("handle-year", Y);
    };
    return (Y, G) => {
      var h, _, H;
      return M(), W("div", Cl, [
        c(o)(c(d), e.instance) ? (M(), ge(Ot, {
          key: 0,
          ref: "mpPrevIconRef",
          "aria-label": (h = c(b)) == null ? void 0 : h.prevYear,
          disabled: e.isDisabled(!1),
          onActivate: G[0] || (G[0] = (k) => B(!1))
        }, {
          default: fe(() => [
            Y.$slots["arrow-left"] ? le(Y.$slots, "arrow-left", { key: 0 }) : K("", !0),
            Y.$slots["arrow-left"] ? K("", !0) : (M(), ge(c(En), { key: 1 }))
          ]),
          _: 3
        }, 8, ["aria-label", "disabled"])) : K("", !0),
        de("button", {
          ref: "mpYearButtonRef",
          class: "dp__btn dp--year-select",
          type: "button",
          "aria-label": (_ = c(b)) == null ? void 0 : _.openYearsOverlay,
          onClick: G[1] || (G[1] = () => U(!1)),
          onKeydown: G[2] || (G[2] = ue(() => U(!1), ["enter"]))
        }, [
          Y.$slots.year ? le(Y.$slots, "year", {
            key: 0,
            year: e.year
          }) : K("", !0),
          Y.$slots.year ? K("", !0) : (M(), W(ve, { key: 1 }, [
            rt(Ye(e.year), 1)
          ], 64))
        ], 40, _l),
        c(n)(c(d), e.instance) ? (M(), ge(Ot, {
          key: 1,
          ref: "mpNextIconRef",
          "aria-label": (H = c(b)) == null ? void 0 : H.nextYear,
          disabled: e.isDisabled(!0),
          onActivate: G[3] || (G[3] = (k) => B(!0))
        }, {
          default: fe(() => [
            Y.$slots["arrow-right"] ? le(Y.$slots, "arrow-right", { key: 0 }) : K("", !0),
            Y.$slots["arrow-right"] ? K("", !0) : (M(), ge(c(Fn), { key: 1 }))
          ]),
          _: 3
        }, 8, ["aria-label", "disabled"])) : K("", !0),
        We(Pt, {
          name: c(p)(e.showYearPicker),
          css: c(T)
        }, {
          default: fe(() => [
            e.showYearPicker ? (M(), ge(Ut, {
              key: 0,
              items: e.items,
              "text-input": Y.textInput,
              "esc-close": Y.escClose,
              config: Y.config,
              "is-last": Y.autoApply && !c(i).keepActionRow,
              type: "year",
              onToggle: U,
              onSelected: G[4] || (G[4] = (k) => L(k))
            }, Ee({
              "button-icon": fe(() => [
                Y.$slots["calendar-icon"] ? le(Y.$slots, "calendar-icon", { key: 0 }) : K("", !0),
                Y.$slots["calendar-icon"] ? K("", !0) : (M(), ge(c(Ft), { key: 1 }))
              ]),
              _: 2
            }, [
              Y.$slots["year-overlay-value"] ? {
                name: "item",
                fn: fe(({ item: k }) => [
                  le(Y.$slots, "year-overlay-value", {
                    text: k.text,
                    value: k.value
                  })
                ]),
                key: "0"
              } : void 0
            ]), 1032, ["items", "text-input", "esc-close", "config", "is-last"])) : K("", !0)
          ]),
          _: 3
        }, 8, ["name", "css"])
      ]);
    };
  }
}), Gn = (e, t, r) => {
  if (t.value && Array.isArray(t.value))
    if (t.value.some((a) => pe(e, a))) {
      const a = t.value.filter((n) => !pe(n, e));
      t.value = a.length ? a : null;
    } else
      (r && +r > t.value.length || !r) && t.value.push(e);
  else
    t.value = [e];
}, qn = (e, t, r) => {
  let a = e.value ? e.value.slice() : [];
  return a.length === 2 && a[1] !== null && (a = []), a.length ? _e(t, a[0]) ? (a.unshift(t), r("range-start", a[0]), r("range-start", a[1])) : (a[1] = t, r("range-end", t)) : (a = [t], r("range-start", t)), e.value = a, a;
}, tn = (e, t, r, a) => {
  e[0] && e[1] && r && t("auto-apply"), e[0] && !e[1] && a && r && t("auto-apply");
}, La = ({
  multiCalendars: e,
  highlight: t,
  calendars: r,
  modelValue: a,
  props: n,
  year: o,
  month: i,
  emit: d
}) => {
  const b = Z(() => jn(n.yearRange, n.reverseYears)), P = ee([!1]), T = Z(() => (k, R) => {
    const Q = De(Qe(/* @__PURE__ */ new Date()), {
      month: i.value(k),
      year: o.value(k)
    });
    return Ea(Q, n.maxDate, n.minDate, n.preventMinMaxNavigation, R);
  }), p = () => {
    for (let k = 0; k < e.value.count; k++)
      if (k === 0)
        r.value[k] = r.value[0];
      else {
        const R = De(V(), r.value[k - 1]);
        r.value[k] = { month: he(R), year: ce(Ma(R, 1)) };
      }
  }, U = (k) => {
    if (!k)
      return p();
    const R = De(V(), r.value[k]);
    return r.value[0].year = ce($a(R, e.value.count - 1)), p();
  }, L = (k) => n.focusStartDate ? k[0] : k[1] ? k[1] : k[0], B = () => {
    if (a.value) {
      const k = Array.isArray(a.value) ? L(a.value) : a.value;
      r.value[0] = { month: he(k), year: ce(k) };
    }
  };
  ze(() => {
    B(), e.value.count && p();
  });
  const Y = (k, R) => {
    r.value[R].year = k, e.value.count && !e.value.solo && U(R);
  }, G = Z(() => (k) => At(b.value, (R) => {
    const Q = o.value(k) === R.value, q = Bt(R.value, St(n.minDate), St(n.maxDate)), x = Kn(t.value, R.value);
    return { active: Q, disabled: q, highlighted: x };
  })), h = (k, R) => {
    Y(k, R), H(R);
  }, _ = (k, R = !1) => {
    if (!T.value(k, R)) {
      const Q = R ? o.value(k) + 1 : o.value(k) - 1;
      Y(Q, k);
    }
  }, H = (k, R = !1, Q) => {
    R || d("reset-flow"), Q !== void 0 ? P.value[k] = Q : P.value[k] = !P.value[k], P.value || d("overlay-closed");
  };
  return {
    isDisabled: T,
    groupedYears: G,
    showYearPicker: P,
    selectYear: Y,
    toggleYearPicker: H,
    handleYearSelect: h,
    handleYear: _
  };
}, Rl = (e, t) => {
  const { defaultedMultiCalendars: r, defaultedAriaLabels: a, defaultedTransitions: n, defaultedConfig: o, defaultedHighlight: i } = Te(e), { modelValue: d, year: b, month: P, calendars: T } = Vt(e, t), p = Z(() => _a(e.formatLocale, e.locale, e.monthNameFormat)), U = ee(null), {
    selectYear: L,
    groupedYears: B,
    showYearPicker: Y,
    toggleYearPicker: G,
    handleYearSelect: h,
    handleYear: _,
    isDisabled: H
  } = La({
    modelValue: d,
    multiCalendars: r,
    highlight: i,
    calendars: T,
    year: b,
    month: P,
    props: e,
    emit: t
  }), k = (S) => S ? { month: he(S), year: ce(S) } : { month: null, year: null }, R = () => d.value ? Array.isArray(d.value) ? d.value.map((S) => k(S)) : k(d.value) : k(), Q = (S, w) => {
    const l = T.value[S], g = R();
    return Array.isArray(g) ? g.some((s) => s.year === (l == null ? void 0 : l.year) && s.month === w) : (l == null ? void 0 : l.year) === g.year && w === g.month;
  }, q = (S, w, l) => {
    var s, D;
    const g = R();
    return Array.isArray(g) ? b.value(w) === ((s = g[l]) == null ? void 0 : s.year) && S === ((D = g[l]) == null ? void 0 : D.month) : !1;
  }, x = (S, w) => {
    if (e.range) {
      const l = R();
      if (Array.isArray(d.value) && Array.isArray(l)) {
        const g = q(S, w, 0) || q(S, w, 1), s = at(Qe(V()), S, b.value(w));
        return Xt(d.value, U.value, s) && !g;
      }
      return !1;
    }
    return !1;
  }, se = Z(() => (S) => At(p.value, (w) => {
    const l = Q(S, w.value), g = Bt(
      w.value,
      Oa(b.value(S), e.minDate),
      Ya(b.value(S), e.maxDate)
    ) || Jr(e.disabledDates, b.value(S)).includes(w.value), s = x(w.value, S), D = Ha(i.value, w.value, b.value(S));
    return { active: l, disabled: g, isBetween: s, highlighted: D };
  })), E = (S, w) => at(Qe(V()), S, b.value(w)), m = (S, w) => {
    const l = d.value ? d.value : Qe(/* @__PURE__ */ new Date());
    d.value = at(l, S, b.value(w)), t("auto-apply");
  }, $ = (S, w) => {
    const l = qn(d, E(S, w), t);
    tn(l, t, e.autoApply, e.modelAuto);
  }, j = (S, w) => {
    Gn(E(S, w), d, e.multiDatesLimit), t("auto-apply", !0);
  }, te = (S, w) => (T.value[w].month = S, y(w, T.value[w].year, S), e.multiDates ? j(S, w) : e.range ? $(S, w) : m(S, w)), f = (S, w) => {
    L(S, w), y(w, S, null);
  }, y = (S, w, l) => {
    let g = l;
    if (!g) {
      const s = R();
      g = Array.isArray(s) ? s[S].month : s.month;
    }
    t("update-month-year", { instance: S, year: w, month: g });
  };
  return {
    groupedMonths: se,
    groupedYears: B,
    year: b,
    isDisabled: H,
    defaultedMultiCalendars: r,
    defaultedAriaLabels: a,
    defaultedTransitions: n,
    defaultedConfig: o,
    showYearPicker: Y,
    modelValue: d,
    setHoverDate: (S, w) => {
      U.value = E(S, w);
    },
    selectMonth: te,
    selectYear: f,
    toggleYearPicker: G,
    handleYearSelect: h,
    handleYear: _,
    getModelMonthYear: R
  };
}, Ol = /* @__PURE__ */ Oe({
  compatConfig: {
    MODE: 3
  },
  __name: "MonthPicker",
  props: {
    ...xe
  },
  emits: [
    "update:internal-model-value",
    "overlay-closed",
    "reset-flow",
    "range-start",
    "range-end",
    "auto-apply",
    "update-month-year"
  ],
  setup(e, { expose: t, emit: r }) {
    const a = r, n = kt(), o = Ve(n, "yearMode"), i = e, {
      groupedMonths: d,
      groupedYears: b,
      year: P,
      isDisabled: T,
      defaultedMultiCalendars: p,
      defaultedConfig: U,
      showYearPicker: L,
      modelValue: B,
      setHoverDate: Y,
      selectMonth: G,
      selectYear: h,
      toggleYearPicker: _,
      handleYearSelect: H,
      handleYear: k,
      getModelMonthYear: R
    } = Rl(i, a);
    return t({ getSidebarProps: () => ({
      modelValue: B,
      year: P,
      getModelMonthYear: R,
      selectMonth: G,
      selectYear: h,
      handleYear: k
    }) }), (q, x) => (M(), ge(en, {
      "multi-calendars": c(p).count,
      stretch: ""
    }, {
      default: fe(({ instance: se }) => [
        q.$slots["month-year"] ? le(q.$slots, "month-year", Pe(Re({ key: 0 }, {
          year: c(P),
          months: c(d)(se),
          years: c(b)(se),
          selectMonth: c(G),
          selectYear: c(h),
          instance: se
        }))) : (M(), ge(Ut, {
          key: 1,
          items: c(d)(se),
          "arrow-navigation": q.arrowNavigation,
          "is-last": q.autoApply && !c(U).keepActionRow,
          "esc-close": q.escClose,
          height: c(U).modeHeight,
          config: q.config,
          "no-overlay-focus": q.noOverlayFocus,
          "use-relative": "",
          type: "month",
          onSelected: (E) => c(G)(E, se),
          onHoverValue: (E) => c(Y)(E, se)
        }, {
          header: fe(() => [
            We(Ua, Re(q.$props, {
              items: c(b)(se),
              instance: se,
              "show-year-picker": c(L)[se],
              year: c(P)(se),
              "is-disabled": (E) => c(T)(se, E),
              onHandleYear: (E) => c(k)(se, E),
              onYearSelect: (E) => c(H)(E, se),
              onToggleYearPicker: (E) => c(_)(se, E == null ? void 0 : E.flow, E == null ? void 0 : E.show)
            }), Ee({ _: 2 }, [
              Me(c(o), (E, m) => ({
                name: E,
                fn: fe(($) => [
                  le(q.$slots, E, Pe(Fe($)))
                ])
              }))
            ]), 1040, ["items", "instance", "show-year-picker", "year", "is-disabled", "onHandleYear", "onYearSelect", "onToggleYearPicker"])
          ]),
          _: 2
        }, 1032, ["items", "arrow-navigation", "is-last", "esc-close", "height", "config", "no-overlay-focus", "onSelected", "onHoverValue"]))
      ]),
      _: 3
    }, 8, ["multi-calendars"]));
  }
}), Yl = (e, t) => {
  const { modelValue: r } = Vt(e, t), a = ee(null), { defaultedHighlight: n } = Te(e), o = (p) => Array.isArray(r.value) ? r.value.some((U) => ce(U) === p) : r.value ? ce(r.value) === p : !1, i = (p) => e.range && Array.isArray(r.value) ? Xt(r.value, a.value, b(p)) : !1, d = Z(() => At(jn(e.yearRange, e.reverseYears), (p) => {
    const U = o(p.value), L = Bt(p.value, St(e.minDate), St(e.maxDate)), B = i(p.value), Y = Kn(n.value, p.value);
    return { active: U, disabled: L, isBetween: B, highlighted: Y };
  })), b = (p) => tt(Qe(/* @__PURE__ */ new Date()), p);
  return {
    groupedYears: d,
    modelValue: r,
    setHoverValue: (p) => {
      a.value = tt(Qe(/* @__PURE__ */ new Date()), p);
    },
    selectYear: (p) => {
      var U;
      if (e.multiDates)
        return r.value ? Array.isArray(r.value) && (((U = r.value) == null ? void 0 : U.map((B) => ce(B))).includes(p) ? r.value = r.value.filter((B) => ce(B) !== p) : r.value.push(tt(He(V()), p))) : r.value = [tt(He(V()), p)], t("auto-apply", !0);
      if (e.range) {
        const L = qn(r, b(p), t);
        return tn(L, t, e.autoApply, e.modelAuto);
      }
      r.value = b(p), t("auto-apply");
    }
  };
}, Nl = /* @__PURE__ */ Oe({
  compatConfig: {
    MODE: 3
  },
  __name: "YearPicker",
  props: {
    ...xe
  },
  emits: ["update:internal-model-value", "reset-flow", "range-start", "range-end", "auto-apply"],
  setup(e, { expose: t, emit: r }) {
    const a = r, n = e, { groupedYears: o, modelValue: i, selectYear: d, setHoverValue: b } = Yl(n, a), { defaultedConfig: P } = Te(n);
    return t({ getSidebarProps: () => ({
      modelValue: i,
      selectYear: d
    }) }), (p, U) => (M(), W("div", null, [
      p.$slots["month-year"] ? le(p.$slots, "month-year", Pe(Re({ key: 0 }, {
        years: c(o),
        selectYear: c(d)
      }))) : (M(), ge(Ut, {
        key: 1,
        items: c(o),
        "is-last": p.autoApply && !c(P).keepActionRow,
        height: c(P).modeHeight,
        config: p.config,
        "no-overlay-focus": p.noOverlayFocus,
        type: "year",
        "use-relative": "",
        onSelected: c(d),
        onHoverValue: c(b)
      }, Ee({ _: 2 }, [
        p.$slots["year-overlay-value"] ? {
          name: "item",
          fn: fe(({ item: L }) => [
            le(p.$slots, "year-overlay-value", {
              text: L.text,
              value: L.value
            })
          ]),
          key: "0"
        } : void 0
      ]), 1032, ["items", "is-last", "height", "config", "no-overlay-focus", "onSelected", "onHoverValue"]))
    ]));
  }
}), Il = {
  key: 0,
  class: "dp__time_input"
}, Bl = ["aria-label", "onKeydown", "onClick"], El = /* @__PURE__ */ de("span", { class: "dp__tp_inline_btn_bar dp__tp_btn_in_l" }, null, -1), Fl = /* @__PURE__ */ de("span", { class: "dp__tp_inline_btn_bar dp__tp_btn_in_r" }, null, -1), Hl = ["aria-label", "disabled", "onKeydown", "onClick"], Vl = ["aria-label", "onKeydown", "onClick"], Ul = /* @__PURE__ */ de("span", { class: "dp__tp_inline_btn_bar dp__tp_btn_in_l" }, null, -1), Ll = /* @__PURE__ */ de("span", { class: "dp__tp_inline_btn_bar dp__tp_btn_in_r" }, null, -1), Wl = { key: 0 }, zl = ["aria-label", "onKeydown"], jl = /* @__PURE__ */ Oe({
  compatConfig: {
    MODE: 3
  },
  __name: "TimeInput",
  props: {
    hours: { type: Number, default: 0 },
    minutes: { type: Number, default: 0 },
    seconds: { type: Number, default: 0 },
    closeTimePickerBtn: { type: Object, default: null },
    order: { type: Number, default: 0 },
    disabledTimesConfig: { type: Function, default: null },
    validateTime: { type: Function, default: () => !1 },
    ...xe
  },
  emits: [
    "set-hours",
    "set-minutes",
    "update:hours",
    "update:minutes",
    "update:seconds",
    "reset-flow",
    "mounted",
    "overlay-closed",
    "am-pm-change"
  ],
  setup(e, { expose: t, emit: r }) {
    const a = r, n = e, { setTimePickerElements: o, setTimePickerBackRef: i } = ft(), { defaultedAriaLabels: d, defaultedTransitions: b, defaultedFilters: P, defaultedConfig: T } = Te(n), { transitionName: p, showTransition: U } = Ht(b), L = Et({
      hours: !1,
      minutes: !1,
      seconds: !1
    }), B = ee("AM"), Y = ee(null), G = ee([]);
    ze(() => {
      a("mounted");
    });
    const h = (u) => De(/* @__PURE__ */ new Date(), {
      hours: u.hours,
      minutes: u.minutes,
      seconds: n.enableSeconds ? u.seconds : 0,
      milliseconds: 0
    }), _ = Z(
      () => (u) => te(u, n[u]) || k(u, n[u])
    ), H = Z(() => ({ hours: n.hours, minutes: n.minutes, seconds: n.seconds })), k = (u, O) => n.range && !n.disableTimeRangeValidation ? !n.validateTime(u, O) : !1, R = (u, O) => {
      if (n.range && !n.disableTimeRangeValidation) {
        const X = O ? +n[`${u}Increment`] : -+n[`${u}Increment`], C = n[u] + X;
        return !n.validateTime(u, C);
      }
      return !1;
    }, Q = Z(() => (u) => !y(+n[u] + +n[`${u}Increment`], u) || R(u, !0)), q = Z(() => (u) => !y(+n[u] - +n[`${u}Increment`], u) || R(u, !1)), x = (u, O) => Ta(De(V(), u), O), se = (u, O) => rr(De(V(), u), O), E = Z(
      () => ({
        dp__time_col: !0,
        dp__time_col_block: !n.timePickerInline,
        dp__time_col_reg_block: !n.enableSeconds && n.is24 && !n.timePickerInline,
        dp__time_col_reg_inline: !n.enableSeconds && n.is24 && n.timePickerInline,
        dp__time_col_reg_with_button: !n.enableSeconds && !n.is24,
        dp__time_col_sec: n.enableSeconds && n.is24,
        dp__time_col_sec_with_button: n.enableSeconds && !n.is24
      })
    ), m = Z(() => {
      const u = [{ type: "hours" }, { type: "", separator: !0 }, { type: "minutes" }];
      return n.enableSeconds ? u.concat([{ type: "", separator: !0 }, { type: "seconds" }]) : u;
    }), $ = Z(() => m.value.filter((u) => !u.separator)), j = Z(() => (u) => {
      if (u === "hours") {
        const O = g(+n.hours);
        return { text: O < 10 ? `0${O}` : `${O}`, value: O };
      }
      return { text: n[u] < 10 ? `0${n[u]}` : `${n[u]}`, value: n[u] };
    }), te = (u, O) => {
      var C;
      if (!n.disabledTimesConfig)
        return !1;
      const X = n.disabledTimesConfig(n.order, u === "hours" ? O : void 0);
      return X[u] ? !!((C = X[u]) != null && C.includes(O)) : !0;
    }, f = (u) => {
      const O = n.is24 ? 24 : 12, X = u === "hours" ? O : 60, C = +n[`${u}GridIncrement`], ne = u === "hours" && !n.is24 ? C : 0, me = [];
      for (let ye = ne; ye < X; ye += C)
        me.push({ value: ye, text: ye < 10 ? `0${ye}` : `${ye}` });
      return u === "hours" && !n.is24 && me.push({ value: 0, text: "12" }), At(me, (ye) => ({ active: !1, disabled: P.value.times[u].includes(ye.value) || !y(ye.value, u) || te(u, ye.value) || k(u, ye.value) }));
    }, y = (u, O) => {
      const X = n.minTime ? h(yn(n.minTime)) : null, C = n.maxTime ? h(yn(n.maxTime)) : null, ne = h(yn(H.value, O, u));
      return X && C ? (Yt(ne, C) || $t(ne, C)) && (Nt(ne, X) || $t(ne, X)) : X ? Nt(ne, X) || $t(ne, X) : C ? Yt(ne, C) || $t(ne, C) : !0;
    }, N = (u) => n[`no${u[0].toUpperCase() + u.slice(1)}Overlay`], S = (u) => {
      N(u) || (L[u] = !L[u], L[u] || a("overlay-closed"));
    }, w = (u) => u === "hours" ? Je : u === "minutes" ? nt : Tt, l = (u, O = !0) => {
      const X = O ? x : se, C = O ? +n[`${u}Increment`] : -+n[`${u}Increment`];
      y(+n[u] + C, u) && a(
        `update:${u}`,
        w(u)(X({ [u]: +n[u] }, { [u]: +n[`${u}Increment`] }))
      );
    }, g = (u) => n.is24 ? u : (u >= 12 ? B.value = "PM" : B.value = "AM", Hr(u)), s = () => {
      B.value === "PM" ? (B.value = "AM", a("update:hours", n.hours - 12)) : (B.value = "PM", a("update:hours", n.hours + 12)), a("am-pm-change", B.value);
    }, D = (u) => {
      L[u] = !0;
    }, ie = (u, O, X) => {
      if (u && n.arrowNavigation) {
        Array.isArray(G.value[O]) ? G.value[O][X] = u : G.value[O] = [u];
        const C = G.value.reduce(
          (ne, me) => me.map((ye, I) => [...ne[I] || [], me[I]]),
          []
        );
        i(n.closeTimePickerBtn), Y.value && (C[1] = C[1].concat(Y.value)), o(C, n.order);
      }
    }, oe = (u, O) => (S(u), u === "hours" && !n.is24 ? a(`update:${u}`, B.value === "PM" ? O + 12 : O) : a(`update:${u}`, O));
    return t({ openChildCmp: D }), (u, O) => {
      var X;
      return u.disabled ? K("", !0) : (M(), W("div", Il, [
        (M(!0), W(ve, null, Me(m.value, (C, ne) => {
          var me, ye, I;
          return M(), W("div", {
            key: ne,
            class: be(E.value)
          }, [
            C.separator ? (M(), W(ve, { key: 0 }, [
              rt(" : ")
            ], 64)) : (M(), W(ve, { key: 1 }, [
              de("button", {
                ref_for: !0,
                ref: (F) => ie(F, ne, 0),
                type: "button",
                class: be({
                  dp__btn: !0,
                  dp__inc_dec_button: !u.timePickerInline,
                  dp__inc_dec_button_inline: u.timePickerInline,
                  dp__tp_inline_btn_top: u.timePickerInline,
                  dp__inc_dec_button_disabled: Q.value(C.type)
                }),
                "aria-label": (me = c(d)) == null ? void 0 : me.incrementValue(C.type),
                tabindex: "0",
                onKeydown: [
                  ue(ke((F) => l(C.type), ["prevent"]), ["enter"]),
                  ue(ke((F) => l(C.type), ["prevent"]), ["space"])
                ],
                onClick: (F) => l(C.type)
              }, [
                n.timePickerInline ? (M(), W(ve, { key: 1 }, [
                  El,
                  Fl
                ], 64)) : (M(), W(ve, { key: 0 }, [
                  u.$slots["arrow-up"] ? le(u.$slots, "arrow-up", { key: 0 }) : K("", !0),
                  u.$slots["arrow-up"] ? K("", !0) : (M(), ge(c(Vn), { key: 1 }))
                ], 64))
              ], 42, Bl),
              de("button", {
                ref_for: !0,
                ref: (F) => ie(F, ne, 1),
                type: "button",
                "aria-label": (ye = c(d)) == null ? void 0 : ye.openTpOverlay(C.type),
                class: be({
                  dp__time_display: !0,
                  dp__time_display_block: !u.timePickerInline,
                  dp__time_display_inline: u.timePickerInline,
                  "dp--time-invalid": _.value(C.type),
                  "dp--time-overlay-btn": !_.value(C.type)
                }),
                disabled: N(C.type),
                tabindex: "0",
                onKeydown: [
                  ue(ke((F) => S(C.type), ["prevent"]), ["enter"]),
                  ue(ke((F) => S(C.type), ["prevent"]), ["space"])
                ],
                onClick: (F) => S(C.type)
              }, [
                u.$slots[C.type] ? le(u.$slots, C.type, {
                  key: 0,
                  text: j.value(C.type).text,
                  value: j.value(C.type).value
                }) : K("", !0),
                u.$slots[C.type] ? K("", !0) : (M(), W(ve, { key: 1 }, [
                  rt(Ye(j.value(C.type).text), 1)
                ], 64))
              ], 42, Hl),
              de("button", {
                ref_for: !0,
                ref: (F) => ie(F, ne, 2),
                type: "button",
                class: be({
                  dp__btn: !0,
                  dp__inc_dec_button: !u.timePickerInline,
                  dp__inc_dec_button_inline: u.timePickerInline,
                  dp__tp_inline_btn_bottom: u.timePickerInline,
                  dp__inc_dec_button_disabled: q.value(C.type)
                }),
                "aria-label": (I = c(d)) == null ? void 0 : I.decrementValue(C.type),
                tabindex: "0",
                onKeydown: [
                  ue(ke((F) => l(C.type, !1), ["prevent"]), ["enter"]),
                  ue(ke((F) => l(C.type, !1), ["prevent"]), ["space"])
                ],
                onClick: (F) => l(C.type, !1)
              }, [
                n.timePickerInline ? (M(), W(ve, { key: 1 }, [
                  Ul,
                  Ll
                ], 64)) : (M(), W(ve, { key: 0 }, [
                  u.$slots["arrow-down"] ? le(u.$slots, "arrow-down", { key: 0 }) : K("", !0),
                  u.$slots["arrow-down"] ? K("", !0) : (M(), ge(c(Un), { key: 1 }))
                ], 64))
              ], 42, Vl)
            ], 64))
          ], 2);
        }), 128)),
        u.is24 ? K("", !0) : (M(), W("div", Wl, [
          u.$slots["am-pm-button"] ? le(u.$slots, "am-pm-button", {
            key: 0,
            toggle: s,
            value: B.value
          }) : K("", !0),
          u.$slots["am-pm-button"] ? K("", !0) : (M(), W("button", {
            key: 1,
            ref_key: "amPmButton",
            ref: Y,
            type: "button",
            class: "dp__pm_am_button",
            role: "button",
            "aria-label": (X = c(d)) == null ? void 0 : X.amPmButton,
            tabindex: "0",
            onClick: s,
            onKeydown: [
              ue(ke(s, ["prevent"]), ["enter"]),
              ue(ke(s, ["prevent"]), ["space"])
            ]
          }, Ye(B.value), 41, zl))
        ])),
        (M(!0), W(ve, null, Me($.value, (C, ne) => (M(), ge(Pt, {
          key: ne,
          name: c(p)(L[C.type]),
          css: c(U)
        }, {
          default: fe(() => [
            L[C.type] ? (M(), ge(Ut, {
              key: 0,
              items: f(C.type),
              "is-last": u.autoApply && !c(T).keepActionRow,
              "esc-close": u.escClose,
              type: C.type,
              "text-input": u.textInput,
              config: u.config,
              "arrow-navigation": u.arrowNavigation,
              onSelected: (me) => oe(C.type, me),
              onToggle: (me) => S(C.type),
              onResetFlow: O[0] || (O[0] = (me) => u.$emit("reset-flow"))
            }, Ee({
              "button-icon": fe(() => [
                u.$slots["clock-icon"] ? le(u.$slots, "clock-icon", { key: 0 }) : K("", !0),
                u.$slots["clock-icon"] ? K("", !0) : (M(), ge(c(Hn), { key: 1 }))
              ]),
              _: 2
            }, [
              u.$slots[`${C.type}-overlay-value`] ? {
                name: "item",
                fn: fe(({ item: me }) => [
                  le(u.$slots, `${C.type}-overlay-value`, {
                    text: me.text,
                    value: me.value
                  })
                ]),
                key: "0"
              } : void 0
            ]), 1032, ["items", "is-last", "esc-close", "type", "text-input", "config", "arrow-navigation", "onSelected", "onToggle"])) : K("", !0)
          ]),
          _: 2
        }, 1032, ["name", "css"]))), 128))
      ]));
    };
  }
}), Kl = { class: "dp--tp-wrap" }, Gl = ["aria-label", "tabindex"], ql = ["tabindex"], Zl = ["aria-label"], Wa = /* @__PURE__ */ Oe({
  compatConfig: {
    MODE: 3
  },
  __name: "TimePicker",
  props: {
    hours: { type: [Number, Array], default: 0 },
    minutes: { type: [Number, Array], default: 0 },
    seconds: { type: [Number, Array], default: 0 },
    disabledTimesConfig: { type: Function, default: null },
    validateTime: {
      type: Function,
      default: () => !1
    },
    ...xe
  },
  emits: [
    "update:hours",
    "update:minutes",
    "update:seconds",
    "mount",
    "reset-flow",
    "overlay-opened",
    "overlay-closed",
    "am-pm-change"
  ],
  setup(e, { expose: t, emit: r }) {
    const a = r, n = e, { buildMatrix: o, setTimePicker: i } = ft(), d = kt(), { defaultedTransitions: b, defaultedAriaLabels: P, defaultedTextInput: T, defaultedConfig: p } = Te(n), { transitionName: U, showTransition: L } = Ht(b), { hideNavigationButtons: B } = Jt(), Y = ee(null), G = ee(null), h = ee([]), _ = ee(null);
    ze(() => {
      a("mount"), !n.timePicker && n.arrowNavigation ? o([Se(Y.value)], "time") : i(!0, n.timePicker);
    });
    const H = Z(() => n.range && n.modelAuto ? Ra(n.internalModelValue) : !0), k = ee(!1), R = (f) => ({
      hours: Array.isArray(n.hours) ? n.hours[f] : n.hours,
      minutes: Array.isArray(n.minutes) ? n.minutes[f] : n.minutes,
      seconds: Array.isArray(n.seconds) ? n.seconds[f] : n.seconds
    }), Q = Z(() => {
      const f = [];
      if (n.range)
        for (let y = 0; y < 2; y++)
          f.push(R(y));
      else
        f.push(R(0));
      return f;
    }), q = (f, y = !1, N = "") => {
      y || a("reset-flow"), k.value = f, a(f ? "overlay-opened" : "overlay-closed"), n.arrowNavigation && i(f), ct(() => {
        N !== "" && h.value[0] && h.value[0].openChildCmp(N);
      });
    }, x = Z(() => ({
      dp__btn: !0,
      dp__button: !0,
      dp__button_bottom: n.autoApply && !p.value.keepActionRow
    })), se = Ve(d, "timePicker"), E = (f, y, N) => n.range ? y === 0 ? [f, Q.value[1][N]] : [Q.value[0][N], f] : f, m = (f) => {
      a("update:hours", f);
    }, $ = (f) => {
      a("update:minutes", f);
    }, j = (f) => {
      a("update:seconds", f);
    }, te = () => {
      if (_.value && !T.value.enabled && !n.noOverlayFocus) {
        const f = Ur(_.value);
        f && f.focus({ preventScroll: !0 });
      }
    };
    return t({ toggleTimePicker: q }), (f, y) => {
      var N;
      return M(), W("div", Kl, [
        !f.timePicker && !f.timePickerInline ? jt((M(), W("button", {
          key: 0,
          ref_key: "openTimePickerBtn",
          ref: Y,
          type: "button",
          class: be(x.value),
          "aria-label": (N = c(P)) == null ? void 0 : N.openTimePicker,
          tabindex: f.noOverlayFocus ? void 0 : 0,
          onKeydown: [
            y[0] || (y[0] = ue((S) => q(!0), ["enter"])),
            y[1] || (y[1] = ue((S) => q(!0), ["space"]))
          ],
          onClick: y[2] || (y[2] = (S) => q(!0))
        }, [
          f.$slots["clock-icon"] ? le(f.$slots, "clock-icon", { key: 0 }) : K("", !0),
          f.$slots["clock-icon"] ? K("", !0) : (M(), ge(c(Hn), { key: 1 }))
        ], 42, Gl)), [
          [Kt, !c(B)(f.hideNavigation, "time")]
        ]) : K("", !0),
        We(Pt, {
          name: c(U)(k.value),
          css: c(L) && !f.timePickerInline
        }, {
          default: fe(() => {
            var S;
            return [
              k.value || f.timePicker || f.timePickerInline ? (M(), W("div", {
                key: 0,
                ref_key: "overlayRef",
                ref: _,
                class: be({
                  dp__overlay: !f.timePickerInline,
                  "dp--overlay-absolute": !n.timePicker && !f.timePickerInline,
                  "dp--overlay-relative": n.timePicker
                }),
                style: Xe(f.timePicker ? { height: `${c(p).modeHeight}px` } : void 0),
                tabindex: f.timePickerInline ? void 0 : 0
              }, [
                de("div", {
                  class: be(
                    f.timePickerInline ? "dp__time_picker_inline_container" : "dp__overlay_container dp__container_flex dp__time_picker_overlay_container"
                  ),
                  style: { display: "flex" }
                }, [
                  f.$slots["time-picker-overlay"] ? le(f.$slots, "time-picker-overlay", {
                    key: 0,
                    hours: e.hours,
                    minutes: e.minutes,
                    seconds: e.seconds,
                    setHours: m,
                    setMinutes: $,
                    setSeconds: j
                  }) : K("", !0),
                  f.$slots["time-picker-overlay"] ? K("", !0) : (M(), W("div", {
                    key: 1,
                    class: be(f.timePickerInline ? "dp__flex" : "dp__overlay_row dp__flex_row")
                  }, [
                    (M(!0), W(ve, null, Me(Q.value, (w, l) => jt((M(), ge(jl, Re({ key: l }, {
                      ...f.$props,
                      order: l,
                      hours: w.hours,
                      minutes: w.minutes,
                      seconds: w.seconds,
                      closeTimePickerBtn: G.value,
                      disabledTimesConfig: e.disabledTimesConfig,
                      disabled: l === 0 ? f.fixedStart : f.fixedEnd
                    }, {
                      ref_for: !0,
                      ref_key: "timeInputRefs",
                      ref: h,
                      "validate-time": (g, s) => e.validateTime(g, E(s, l, g)),
                      "onUpdate:hours": (g) => m(E(g, l, "hours")),
                      "onUpdate:minutes": (g) => $(E(g, l, "minutes")),
                      "onUpdate:seconds": (g) => j(E(g, l, "seconds")),
                      onMounted: te,
                      onOverlayClosed: te,
                      onAmPmChange: y[3] || (y[3] = (g) => f.$emit("am-pm-change", g))
                    }), Ee({ _: 2 }, [
                      Me(c(se), (g, s) => ({
                        name: g,
                        fn: fe((D) => [
                          le(f.$slots, g, Pe(Fe(D)))
                        ])
                      }))
                    ]), 1040, ["validate-time", "onUpdate:hours", "onUpdate:minutes", "onUpdate:seconds"])), [
                      [Kt, l === 0 ? !0 : H.value]
                    ])), 128))
                  ], 2)),
                  !f.timePicker && !f.timePickerInline ? jt((M(), W("button", {
                    key: 2,
                    ref_key: "closeTimePickerBtn",
                    ref: G,
                    type: "button",
                    class: be(x.value),
                    "aria-label": (S = c(P)) == null ? void 0 : S.closeTimePicker,
                    tabindex: "0",
                    onKeydown: [
                      y[4] || (y[4] = ue((w) => q(!1), ["enter"])),
                      y[5] || (y[5] = ue((w) => q(!1), ["space"]))
                    ],
                    onClick: y[6] || (y[6] = (w) => q(!1))
                  }, [
                    f.$slots["calendar-icon"] ? le(f.$slots, "calendar-icon", { key: 0 }) : K("", !0),
                    f.$slots["calendar-icon"] ? K("", !0) : (M(), ge(c(Ft), { key: 1 }))
                  ], 42, Zl)), [
                    [Kt, !c(B)(f.hideNavigation, "time")]
                  ]) : K("", !0)
                ], 2)
              ], 14, ql)) : K("", !0)
            ];
          }),
          _: 3
        }, 8, ["name", "css"])
      ]);
    };
  }
}), za = (e, t, r, a) => {
  const n = (h, _) => Array.isArray(t[h]) ? t[h][_] : t[h], o = (h) => e.enableSeconds ? Array.isArray(t.seconds) ? t.seconds[h] : t.seconds : 0, i = (h, _) => h ? _ !== void 0 ? ut(h, n("hours", _), n("minutes", _), o(_)) : ut(h, t.hours, t.minutes, o()) : In(V(), o(_)), d = (h, _) => {
    t[h] = _;
  }, b = (h, _) => {
    const H = Object.fromEntries(
      Object.keys(t).map((k) => k === h ? [k, _] : [k, t[k]].slice())
    );
    if (e.range && !e.disableTimeRangeValidation) {
      const k = (Q) => r.value ? ut(
        r.value[Q],
        H.hours[Q],
        H.minutes[Q],
        H.seconds[Q]
      ) : null, R = (Q) => Bn(r.value[Q], 0);
      return !(pe(k(0), k(1)) && (Nt(k(0), R(1)) || Yt(k(1), R(0))));
    }
    return !0;
  }, P = (h, _) => {
    b(h, _) && (d(h, _), a && a());
  }, T = (h) => {
    P("hours", h);
  }, p = (h) => {
    P("minutes", h);
  }, U = (h) => {
    P("seconds", h);
  }, L = (h, _, H, k) => {
    _ && T(h), !_ && !H && p(h), H && U(h), r.value && k(r.value);
  }, B = (h) => {
    if (h) {
      const _ = Array.isArray(h), H = _ ? [+h[0].hours, +h[1].hours] : +h.hours, k = _ ? [+h[0].minutes, +h[1].minutes] : +h.minutes, R = _ ? [+h[0].seconds, +h[1].seconds] : +h.seconds;
      d("hours", H), d("minutes", k), e.enableSeconds && d("seconds", R);
    }
  }, Y = (h, _) => {
    const H = {
      hours: Array.isArray(t.hours) ? t.hours[h] : t.hours,
      disabledArr: []
    };
    return (_ || _ === 0) && (H.hours = _), Array.isArray(e.disabledTimes) && (H.disabledArr = e.range && Array.isArray(e.disabledTimes[h]) ? e.disabledTimes[h] : e.disabledTimes), H;
  }, G = Z(() => (h, _) => {
    var H;
    if (Array.isArray(e.disabledTimes)) {
      const { disabledArr: k, hours: R } = Y(h, _), Q = k.filter((q) => +q.hours === R);
      return ((H = Q[0]) == null ? void 0 : H.minutes) === "*" ? { hours: [R], minutes: void 0, seconds: void 0 } : {
        hours: [],
        minutes: (Q == null ? void 0 : Q.map((q) => +q.minutes)) ?? [],
        seconds: (Q == null ? void 0 : Q.map((q) => q.seconds ? +q.seconds : void 0)) ?? []
      };
    }
    return { hours: [], minutes: [], seconds: [] };
  });
  return {
    setTime: d,
    updateHours: T,
    updateMinutes: p,
    updateSeconds: U,
    getSetDateTime: i,
    updateTimeValues: L,
    getSecondsValue: o,
    assignStartTime: B,
    validateTime: b,
    disabledTimesConfig: G
  };
}, Ql = (e, t) => {
  const { modelValue: r, time: a } = Vt(e, t), { defaultedStartTime: n } = Te(e), { updateTimeValues: o, getSetDateTime: i, setTime: d, assignStartTime: b, disabledTimesConfig: P, validateTime: T } = za(e, a, r), p = (H) => {
    const { hours: k, minutes: R, seconds: Q } = H;
    return { hours: +k, minutes: +R, seconds: Q ? +Q : 0 };
  }, U = () => {
    if (e.startTime) {
      if (Array.isArray(e.startTime)) {
        const k = p(e.startTime[0]), R = p(e.startTime[1]);
        return [De(V(), k), De(V(), R)];
      }
      const H = p(e.startTime);
      return De(V(), H);
    }
    return e.range ? [null, null] : null;
  }, L = () => {
    if (e.range) {
      const [H, k] = U();
      r.value = [i(H, 0), i(k, 1)];
    } else
      r.value = i(U());
  }, B = (H) => Array.isArray(H) ? [pt(V(H[0])), pt(V(H[1]))] : [pt(H ?? V())], Y = (H, k, R) => {
    d("hours", H), d("minutes", k), d("seconds", e.enableSeconds ? R : 0);
  }, G = () => {
    const [H, k] = B(r.value);
    return e.range ? Y(
      [H.hours, k.hours],
      [H.minutes, k.minutes],
      [H.seconds, k.minutes]
    ) : Y(H.hours, H.minutes, H.seconds);
  };
  ze(() => {
    if (!e.shadow)
      return b(n.value), r.value ? G() : L();
  });
  const h = () => {
    Array.isArray(r.value) ? r.value = r.value.map((H, k) => H && i(H, k)) : r.value = i(r.value), t("time-update");
  };
  return {
    modelValue: r,
    time: a,
    disabledTimesConfig: P,
    updateTime: (H, k = !0, R = !1) => {
      o(H, k, R, h);
    },
    validateTime: T
  };
}, Xl = /* @__PURE__ */ Oe({
  compatConfig: {
    MODE: 3
  },
  __name: "TimePickerSolo",
  props: {
    ...xe
  },
  emits: ["update:internal-model-value", "time-update", "am-pm-change"],
  setup(e, { expose: t, emit: r }) {
    const a = r, n = e, o = kt(), i = Ve(o, "timePicker"), { time: d, modelValue: b, disabledTimesConfig: P, updateTime: T, validateTime: p } = Ql(n, a);
    return t({ getSidebarProps: () => ({
      modelValue: b,
      time: d,
      updateTime: T
    }) }), (L, B) => (M(), ge(en, {
      "multi-calendars": 0,
      stretch: ""
    }, {
      default: fe(() => [
        We(Wa, Re(L.$props, {
          hours: c(d).hours,
          minutes: c(d).minutes,
          seconds: c(d).seconds,
          "internal-model-value": L.internalModelValue,
          "disabled-times-config": c(P),
          "validate-time": c(p),
          "onUpdate:hours": B[0] || (B[0] = (Y) => c(T)(Y)),
          "onUpdate:minutes": B[1] || (B[1] = (Y) => c(T)(Y, !1)),
          "onUpdate:seconds": B[2] || (B[2] = (Y) => c(T)(Y, !1, !0)),
          onAmPmChange: B[3] || (B[3] = (Y) => L.$emit("am-pm-change", Y))
        }), Ee({ _: 2 }, [
          Me(c(i), (Y, G) => ({
            name: Y,
            fn: fe((h) => [
              le(L.$slots, Y, Pe(Fe(h)))
            ])
          }))
        ]), 1040, ["hours", "minutes", "seconds", "internal-model-value", "disabled-times-config", "validate-time"])
      ]),
      _: 3
    }));
  }
}), Jl = { class: "dp__month_year_row" }, xl = ["aria-label", "onClick", "onKeydown"], eo = /* @__PURE__ */ Oe({
  compatConfig: {
    MODE: 3
  },
  __name: "DpHeader",
  props: {
    month: { type: Number, default: 0 },
    year: { type: Number, default: 0 },
    instance: { type: Number, default: 0 },
    years: { type: Array, default: () => [] },
    months: { type: Array, default: () => [] },
    ...xe
  },
  emits: ["update-month-year", "mount", "reset-flow", "overlay-closed"],
  setup(e, { expose: t, emit: r }) {
    const a = r, n = e, {
      defaultedTransitions: o,
      defaultedAriaLabels: i,
      defaultedMultiCalendars: d,
      defaultedFilters: b,
      defaultedConfig: P,
      defaultedHighlight: T
    } = Te(n), { transitionName: p, showTransition: U } = Ht(o), { buildMatrix: L } = ft(), { handleMonthYearChange: B, isDisabled: Y, updateMonthYear: G } = dl(n, a), { showLeftIcon: h, showRightIcon: _ } = Jt(), H = ee(!1), k = ee(!1), R = ee([null, null, null, null]);
    ze(() => {
      a("mount");
    });
    const Q = (l) => ({
      get: () => n[l],
      set: (g) => {
        const s = l === Ze.month ? Ze.year : Ze.month;
        a("update-month-year", { [l]: g, [s]: n[s] }), l === Ze.month ? te(!0) : f(!0);
      }
    }), q = Z(Q(Ze.month)), x = Z(Q(Ze.year)), se = Z(() => (l) => ({
      month: n.month,
      year: n.year,
      items: l === Ze.month ? n.months : n.years,
      instance: n.instance,
      updateMonthYear: G,
      toggle: l === Ze.month ? te : f
    })), E = Z(() => {
      const l = n.months.find((g) => g.value === n.month);
      return l || { text: "", value: 0 };
    }), m = Z(() => At(n.months, (l) => {
      const g = n.month === l.value, s = Bt(
        l.value,
        Oa(n.year, n.minDate),
        Ya(n.year, n.maxDate)
      ) || b.value.months.includes(l.value), D = Ha(T.value, l.value, n.year);
      return { active: g, disabled: s, highlighted: D };
    })), $ = Z(() => At(n.years, (l) => {
      const g = n.year === l.value, s = Bt(l.value, St(n.minDate), St(n.maxDate)) || b.value.years.includes(l.value), D = Kn(T.value, l.value);
      return { active: g, disabled: s, highlighted: D };
    })), j = (l, g) => {
      g !== void 0 ? l.value = g : l.value = !l.value, l.value || a("overlay-closed");
    }, te = (l = !1, g) => {
      y(l), j(H, g);
    }, f = (l = !1, g) => {
      y(l), j(k, g);
    }, y = (l) => {
      l || a("reset-flow");
    }, N = (l, g) => {
      n.arrowNavigation && (R.value[g] = Se(l), L(R.value, "monthYear"));
    }, S = Z(() => {
      var l, g;
      return [
        {
          type: Ze.month,
          index: 1,
          toggle: te,
          modelValue: q.value,
          updateModelValue: (s) => q.value = s,
          text: E.value.text,
          showSelectionGrid: H.value,
          items: m.value,
          ariaLabel: (l = i.value) == null ? void 0 : l.openMonthsOverlay
        },
        {
          type: Ze.year,
          index: 2,
          toggle: f,
          modelValue: x.value,
          updateModelValue: (s) => x.value = s,
          text: n.year,
          showSelectionGrid: k.value,
          items: $.value,
          ariaLabel: (g = i.value) == null ? void 0 : g.openYearsOverlay
        }
      ];
    }), w = Z(() => n.disableYearSelect ? [S.value[0]] : n.yearFirst ? [...S.value].reverse() : S.value);
    return t({
      toggleMonthPicker: te,
      toggleYearPicker: f,
      handleMonthYearChange: B
    }), (l, g) => {
      var s, D, ie;
      return M(), W("div", Jl, [
        l.$slots["month-year"] ? le(l.$slots, "month-year", Pe(Re({ key: 0 }, { month: e.month, year: e.year, months: e.months, years: e.years, updateMonthYear: c(G), handleMonthYearChange: c(B), instance: e.instance }))) : (M(), W(ve, { key: 1 }, [
          c(h)(c(d), e.instance) && !l.vertical ? (M(), ge(Ot, {
            key: 0,
            "aria-label": (s = c(i)) == null ? void 0 : s.prevMonth,
            disabled: c(Y)(!1),
            onActivate: g[0] || (g[0] = (oe) => c(B)(!1, !0)),
            onSetRef: g[1] || (g[1] = (oe) => N(oe, 0))
          }, {
            default: fe(() => [
              l.$slots["arrow-left"] ? le(l.$slots, "arrow-left", { key: 0 }) : K("", !0),
              l.$slots["arrow-left"] ? K("", !0) : (M(), ge(c(En), { key: 1 }))
            ]),
            _: 3
          }, 8, ["aria-label", "disabled"])) : K("", !0),
          de("div", {
            class: be(["dp__month_year_wrap", {
              dp__year_disable_select: l.disableYearSelect
            }])
          }, [
            (M(!0), W(ve, null, Me(w.value, (oe, u) => (M(), W(ve, {
              key: oe.type
            }, [
              de("button", {
                ref_for: !0,
                ref: (O) => N(O, u + 1),
                type: "button",
                class: "dp__btn dp__month_year_select",
                tabindex: "0",
                "aria-label": oe.ariaLabel,
                onClick: oe.toggle,
                onKeydown: [
                  ue(ke(oe.toggle, ["prevent"]), ["enter"]),
                  ue(ke(oe.toggle, ["prevent"]), ["space"])
                ]
              }, [
                l.$slots[oe.type] ? le(l.$slots, oe.type, {
                  key: 0,
                  text: oe.text,
                  value: n[oe.type]
                }) : K("", !0),
                l.$slots[oe.type] ? K("", !0) : (M(), W(ve, { key: 1 }, [
                  rt(Ye(oe.text), 1)
                ], 64))
              ], 40, xl),
              We(Pt, {
                name: c(p)(oe.showSelectionGrid),
                css: c(U)
              }, {
                default: fe(() => [
                  oe.showSelectionGrid ? (M(), ge(Ut, {
                    key: 0,
                    items: oe.items,
                    "arrow-navigation": l.arrowNavigation,
                    "hide-navigation": l.hideNavigation,
                    "is-last": l.autoApply && !c(P).keepActionRow,
                    "skip-button-ref": !1,
                    config: l.config,
                    type: oe.type,
                    "header-refs": [],
                    "esc-close": l.escClose,
                    "text-input": l.textInput,
                    onSelected: oe.updateModelValue,
                    onToggle: oe.toggle
                  }, Ee({
                    "button-icon": fe(() => [
                      l.$slots["calendar-icon"] ? le(l.$slots, "calendar-icon", { key: 0 }) : K("", !0),
                      l.$slots["calendar-icon"] ? K("", !0) : (M(), ge(c(Ft), { key: 1 }))
                    ]),
                    _: 2
                  }, [
                    l.$slots[`${oe.type}-overlay-value`] ? {
                      name: "item",
                      fn: fe(({ item: O }) => [
                        le(l.$slots, `${oe.type}-overlay-value`, {
                          text: O.text,
                          value: O.value
                        })
                      ]),
                      key: "0"
                    } : void 0,
                    l.$slots[`${oe.type}-overlay`] ? {
                      name: "overlay",
                      fn: fe(() => [
                        le(l.$slots, `${oe.type}-overlay`, Pe(Fe(se.value(oe.type))))
                      ]),
                      key: "1"
                    } : void 0,
                    l.$slots[`${oe.type}-overlay-header`] ? {
                      name: "header",
                      fn: fe(() => [
                        le(l.$slots, `${oe.type}-overlay-header`, {
                          toggle: oe.toggle
                        })
                      ]),
                      key: "2"
                    } : void 0
                  ]), 1032, ["items", "arrow-navigation", "hide-navigation", "is-last", "config", "type", "esc-close", "text-input", "onSelected", "onToggle"])) : K("", !0)
                ]),
                _: 2
              }, 1032, ["name", "css"])
            ], 64))), 128))
          ], 2),
          c(h)(c(d), e.instance) && l.vertical ? (M(), ge(Ot, {
            key: 1,
            "aria-label": (D = c(i)) == null ? void 0 : D.prevMonth,
            disabled: c(Y)(!1),
            onActivate: g[2] || (g[2] = (oe) => c(B)(!1, !0))
          }, {
            default: fe(() => [
              l.$slots["arrow-up"] ? le(l.$slots, "arrow-up", { key: 0 }) : K("", !0),
              l.$slots["arrow-up"] ? K("", !0) : (M(), ge(c(Vn), { key: 1 }))
            ]),
            _: 3
          }, 8, ["aria-label", "disabled"])) : K("", !0),
          c(_)(c(d), e.instance) ? (M(), ge(Ot, {
            key: 2,
            ref: "rightIcon",
            disabled: c(Y)(!0),
            "aria-label": (ie = c(i)) == null ? void 0 : ie.nextMonth,
            onActivate: g[3] || (g[3] = (oe) => c(B)(!0, !0)),
            onSetRef: g[4] || (g[4] = (oe) => N(oe, l.disableYearSelect ? 2 : 3))
          }, {
            default: fe(() => [
              l.$slots[l.vertical ? "arrow-down" : "arrow-right"] ? le(l.$slots, l.vertical ? "arrow-down" : "arrow-right", { key: 0 }) : K("", !0),
              l.$slots[l.vertical ? "arrow-down" : "arrow-right"] ? K("", !0) : (M(), ge(Nn(l.vertical ? c(Un) : c(Fn)), { key: 1 }))
            ]),
            _: 3
          }, 8, ["disabled", "aria-label"])) : K("", !0)
        ], 64))
      ]);
    };
  }
}), to = ["aria-label"], no = {
  class: "dp__calendar_header",
  role: "row"
}, ao = {
  key: 0,
  class: "dp__calendar_header_item",
  role: "gridcell"
}, ro = /* @__PURE__ */ de("div", { class: "dp__calendar_header_separator" }, null, -1), lo = ["aria-label"], oo = {
  key: 0,
  role: "gridcell",
  class: "dp__calendar_item dp__week_num"
}, so = { class: "dp__cell_inner" }, io = ["id", "aria-selected", "aria-disabled", "aria-label", "onClick", "onKeydown", "onMouseenter", "onMouseleave"], uo = /* @__PURE__ */ Oe({
  compatConfig: {
    MODE: 3
  },
  __name: "DpCalendar",
  props: {
    mappedDates: { type: Array, default: () => [] },
    instance: { type: Number, default: 0 },
    month: { type: Number, default: 0 },
    year: { type: Number, default: 0 },
    ...xe
  },
  emits: [
    "select-date",
    "set-hover-date",
    "handle-scroll",
    "mount",
    "handle-swipe",
    "handle-space",
    "tooltip-open",
    "tooltip-close"
  ],
  setup(e, { expose: t, emit: r }) {
    const a = r, n = e, { buildMultiLevelMatrix: o } = ft(), { defaultedTransitions: i, defaultedConfig: d, defaultedAriaLabels: b, defaultedMultiCalendars: P } = Te(n), T = ee(null), p = ee({
      bottom: "",
      left: "",
      transform: ""
    }), U = ee([]), L = ee(null), B = ee(!0), Y = ee(""), G = ee({ startX: 0, endX: 0, startY: 0, endY: 0 }), h = ee([]), _ = ee({ left: "50%" }), H = Z(() => n.calendar ? n.calendar(n.mappedDates) : n.mappedDates), k = Z(() => n.dayNames ? Array.isArray(n.dayNames) ? n.dayNames : n.dayNames(n.locale, +n.weekStart) : Fr(n.formatLocale, n.locale, +n.weekStart));
    ze(() => {
      a("mount", { cmp: "calendar", refs: U }), d.value.noSwipe || L.value && (L.value.addEventListener("touchstart", te, { passive: !1 }), L.value.addEventListener("touchend", f, { passive: !1 }), L.value.addEventListener("touchmove", y, { passive: !1 })), n.monthChangeOnScroll && L.value && L.value.addEventListener("wheel", w, { passive: !1 });
    });
    const R = (D) => D ? n.vertical ? "vNext" : "next" : n.vertical ? "vPrevious" : "previous", Q = (D, ie) => {
      if (n.transitions) {
        const oe = He(at(V(), n.month, n.year));
        Y.value = Ne(He(at(V(), D, ie)), oe) ? i.value[R(!0)] : i.value[R(!1)], B.value = !1, ct(() => {
          B.value = !0;
        });
      }
    }, q = Z(
      () => ({
        [n.calendarClassName]: !!n.calendarClassName
      })
    ), x = Z(() => (D) => {
      const ie = Vr(D);
      return {
        dp__marker_dot: ie.type === "dot",
        dp__marker_line: ie.type === "line"
      };
    }), se = Z(() => (D) => pe(D, T.value)), E = Z(() => ({
      dp__calendar: !0,
      dp__calendar_next: P.value.count > 0 && n.instance !== 0
    })), m = Z(() => (D) => n.hideOffsetDates ? D.current : !0), $ = async (D, ie, oe) => {
      var u, O;
      if (a("set-hover-date", D), (O = (u = D.marker) == null ? void 0 : u.tooltip) != null && O.length) {
        const X = Se(U.value[ie][oe]);
        if (X) {
          const { width: C, height: ne } = X.getBoundingClientRect();
          T.value = D.value;
          let me = { left: `${C / 2}px` }, ye = -50;
          if (await ct(), h.value[0]) {
            const { left: I, width: F } = h.value[0].getBoundingClientRect();
            I < 0 && (me = { left: "0" }, ye = 0, _.value.left = `${C / 2}px`), window.innerWidth < I + F && (me = { right: "0" }, ye = 0, _.value.left = `${F - C / 2}px`);
          }
          p.value = {
            bottom: `${ne}px`,
            ...me,
            transform: `translateX(${ye}%)`
          }, a("tooltip-open", D.marker);
        }
      }
    }, j = (D) => {
      T.value && (T.value = null, p.value = JSON.parse(JSON.stringify({ bottom: "", left: "", transform: "" })), a("tooltip-close", D.marker));
    }, te = (D) => {
      G.value.startX = D.changedTouches[0].screenX, G.value.startY = D.changedTouches[0].screenY;
    }, f = (D) => {
      G.value.endX = D.changedTouches[0].screenX, G.value.endY = D.changedTouches[0].screenY, N();
    }, y = (D) => {
      n.vertical && !n.inline && D.preventDefault();
    }, N = () => {
      const D = n.vertical ? "Y" : "X";
      Math.abs(G.value[`start${D}`] - G.value[`end${D}`]) > 10 && a("handle-swipe", G.value[`start${D}`] > G.value[`end${D}`] ? "right" : "left");
    }, S = (D, ie, oe) => {
      D && (Array.isArray(U.value[ie]) ? U.value[ie][oe] = D : U.value[ie] = [D]), n.arrowNavigation && o(U.value, "calendar");
    }, w = (D) => {
      n.monthChangeOnScroll && (D.preventDefault(), a("handle-scroll", D));
    }, l = (D) => {
      const ie = D[0];
      return n.weekNumbers === "local" ? lr(ie.value, { weekStartsOn: +n.weekStart }) : n.weekNumbers === "iso" ? or(ie.value) : typeof n.weekNumbers == "function" ? n.weekNumbers(ie.value) : "";
    }, g = (D, ie) => {
      it(D, d.value), a("select-date", ie);
    }, s = (D) => {
      it(D, d.value);
    };
    return t({ triggerTransition: Q }), (D, ie) => {
      var oe;
      return M(), W("div", {
        class: be(E.value)
      }, [
        de("div", {
          ref_key: "calendarWrapRef",
          ref: L,
          role: "grid",
          class: be(q.value),
          "aria-label": (oe = c(b)) == null ? void 0 : oe.calendarWrap
        }, [
          (M(), W(ve, { key: 0 }, [
            de("div", no, [
              D.weekNumbers ? (M(), W("div", ao, Ye(D.weekNumName), 1)) : K("", !0),
              (M(!0), W(ve, null, Me(k.value, (u, O) => (M(), W("div", {
                key: O,
                class: "dp__calendar_header_item",
                role: "gridcell"
              }, [
                D.$slots["calendar-header"] ? le(D.$slots, "calendar-header", {
                  key: 0,
                  day: u,
                  index: O
                }) : K("", !0),
                D.$slots["calendar-header"] ? K("", !0) : (M(), W(ve, { key: 1 }, [
                  rt(Ye(u), 1)
                ], 64))
              ]))), 128))
            ]),
            ro,
            We(Pt, {
              name: Y.value,
              css: !!D.transitions
            }, {
              default: fe(() => {
                var u;
                return [
                  B.value ? (M(), W("div", {
                    key: 0,
                    class: "dp__calendar",
                    role: "rowgroup",
                    "aria-label": ((u = c(b)) == null ? void 0 : u.calendarDays) || void 0
                  }, [
                    (M(!0), W(ve, null, Me(H.value, (O, X) => (M(), W("div", {
                      key: X,
                      class: "dp__calendar_row",
                      role: "row"
                    }, [
                      D.weekNumbers ? (M(), W("div", oo, [
                        de("div", so, Ye(l(O.days)), 1)
                      ])) : K("", !0),
                      (M(!0), W(ve, null, Me(O.days, (C, ne) => {
                        var me, ye, I;
                        return M(), W("div", {
                          id: C.value.toISOString().split("T")[0],
                          ref_for: !0,
                          ref: (F) => S(F, X, ne),
                          key: ne + X,
                          role: "gridcell",
                          class: "dp__calendar_item",
                          "aria-selected": C.classData.dp__active_date || C.classData.dp__range_start || C.classData.dp__range_start,
                          "aria-disabled": C.classData.dp__cell_disabled || void 0,
                          "aria-label": (ye = (me = c(b)) == null ? void 0 : me.day) == null ? void 0 : ye.call(me, C),
                          tabindex: "0",
                          onClick: ke((F) => g(F, C), ["prevent"]),
                          onKeydown: [
                            ue((F) => D.$emit("select-date", C), ["enter"]),
                            ue((F) => D.$emit("handle-space", C), ["space"])
                          ],
                          onMouseenter: (F) => $(C, X, ne),
                          onMouseleave: (F) => j(C)
                        }, [
                          de("div", {
                            class: be(["dp__cell_inner", C.classData])
                          }, [
                            D.$slots.day && m.value(C) ? le(D.$slots, "day", {
                              key: 0,
                              day: +C.text,
                              date: C.value
                            }) : K("", !0),
                            D.$slots.day ? K("", !0) : (M(), W(ve, { key: 1 }, [
                              rt(Ye(C.text), 1)
                            ], 64)),
                            C.marker && m.value(C) ? (M(), W(ve, { key: 2 }, [
                              D.$slots.marker ? le(D.$slots, "marker", {
                                key: 0,
                                marker: C.marker,
                                day: +C.text,
                                date: C.value
                              }) : (M(), W("div", {
                                key: 1,
                                class: be(x.value(C.marker)),
                                style: Xe(C.marker.color ? { backgroundColor: C.marker.color } : {})
                              }, null, 6))
                            ], 64)) : K("", !0),
                            se.value(C.value) ? (M(), W("div", {
                              key: 3,
                              ref_for: !0,
                              ref_key: "activeTooltip",
                              ref: h,
                              class: "dp__marker_tooltip",
                              style: Xe(p.value)
                            }, [
                              (I = C.marker) != null && I.tooltip ? (M(), W("div", {
                                key: 0,
                                class: "dp__tooltip_content",
                                onClick: s
                              }, [
                                (M(!0), W(ve, null, Me(C.marker.tooltip, (F, $e) => (M(), W("div", {
                                  key: $e,
                                  class: "dp__tooltip_text"
                                }, [
                                  D.$slots["marker-tooltip"] ? le(D.$slots, "marker-tooltip", {
                                    key: 0,
                                    tooltip: F,
                                    day: C.value
                                  }) : K("", !0),
                                  D.$slots["marker-tooltip"] ? K("", !0) : (M(), W(ve, { key: 1 }, [
                                    de("div", {
                                      class: "dp__tooltip_mark",
                                      style: Xe(F.color ? { backgroundColor: F.color } : {})
                                    }, null, 4),
                                    de("div", null, Ye(F.text), 1)
                                  ], 64))
                                ]))), 128)),
                                de("div", {
                                  class: "dp__arrow_bottom_tp",
                                  style: Xe(_.value)
                                }, null, 4)
                              ])) : K("", !0)
                            ], 4)) : K("", !0)
                          ], 2)
                        ], 40, io);
                      }), 128))
                    ]))), 128))
                  ], 8, lo)) : K("", !0)
                ];
              }),
              _: 3
            }, 8, ["name", "css"])
          ], 64))
        ], 10, to)
      ], 2);
    };
  }
}), ha = (e) => Array.isArray(e), co = (e, t, r, a) => {
  const n = ee([]), { modelValue: o, calendars: i, time: d } = Vt(e, t), { defaultedMultiCalendars: b, defaultedStartTime: P } = Te(e), { validateMonthYearInRange: T, isDisabled: p, isDateRangeAllowed: U, checkMinMaxRange: L } = Ct(e), { updateTimeValues: B, getSetDateTime: Y, setTime: G, assignStartTime: h, validateTime: _, disabledTimesConfig: H } = za(e, d, o, a), k = Z(
    () => (v) => i.value[v] ? i.value[v].month : 0
  ), R = Z(
    () => (v) => i.value[v] ? i.value[v].year : 0
  ), Q = (v, z, A) => {
    var J, re;
    i.value[v] || (i.value[v] = { month: 0, year: 0 }), i.value[v].month = ca(z) ? (J = i.value[v]) == null ? void 0 : J.month : z, i.value[v].year = ca(A) ? (re = i.value[v]) == null ? void 0 : re.year : A;
  }, q = () => {
    e.autoApply && t("select-date");
  };
  dt(o, (v, z) => {
    JSON.stringify(v) !== JSON.stringify(z) && E();
  }), ze(() => {
    e.shadow || (o.value || (l(), P.value && h(P.value)), E(!0), e.focusStartDate && e.startDate && l());
  });
  const x = Z(() => {
    var v;
    return (v = e.flow) != null && v.length && !e.partialFlow ? e.flowStep === e.flow.length : !0;
  }), se = () => {
    e.autoApply && x.value && t("auto-apply", e.partialFlow);
  }, E = (v = !1) => {
    if (o.value)
      return Array.isArray(o.value) ? (n.value = o.value, y(v)) : $(o.value, v);
    if (b.value.count && v && !e.startDate)
      return m(V(), v);
  }, m = (v, z = !1) => {
    if ((!b.value.count || !b.value.static || z) && Q(0, he(v), ce(v)), b.value.count)
      for (let A = 1; A < b.value.count; A++) {
        const J = De(V(), { month: k.value(A - 1), year: R.value(A - 1) }), re = Ta(J, { months: 1 });
        i.value[A] = { month: he(re), year: ce(re) };
      }
  }, $ = (v, z) => {
    m(v), G("hours", Je(v)), G("minutes", nt(v)), G("seconds", Tt(v)), b.value.count && z && w();
  }, j = (v) => {
    if (b.value.count) {
      if (b.value.solo)
        return 0;
      const z = he(v[0]), A = he(v[1]);
      return Math.abs(A - z) < b.value.count ? 0 : 1;
    }
    return 1;
  }, te = (v, z) => {
    v[1] && e.showLastInRange ? m(v[j(v)], z) : m(v[0], z);
    const A = (J, re) => [
      J(v[0]),
      v[1] ? J(v[1]) : d[re][1]
    ];
    G("hours", A(Je, "hours")), G("minutes", A(nt, "minutes")), G("seconds", A(Tt, "seconds"));
  }, f = (v, z) => {
    if ((e.range || e.weekPicker) && !e.multiDates)
      return te(v, z);
    if (e.multiDates && z) {
      const A = v[v.length - 1];
      return $(A, z);
    }
  }, y = (v) => {
    const z = o.value;
    f(z, v), b.value.count && b.value.solo && w();
  }, N = (v, z) => {
    const A = De(V(), { month: k.value(z), year: R.value(z) }), J = v < 0 ? ht(A, 1) : It(A, 1);
    T(he(J), ce(J), v < 0, e.preventMinMaxNavigation) && (Q(z, he(J), ce(J)), t("update-month-year", { instance: z, month: he(J), year: ce(J) }), b.value.count && !b.value.solo && S(z), r());
  }, S = (v) => {
    for (let z = v - 1; z >= 0; z--) {
      const A = It(De(V(), { month: k.value(z + 1), year: R.value(z + 1) }), 1);
      Q(z, he(A), ce(A));
    }
    for (let z = v + 1; z <= b.value.count - 1; z++) {
      const A = ht(De(V(), { month: k.value(z - 1), year: R.value(z - 1) }), 1);
      Q(z, he(A), ce(A));
    }
  }, w = () => {
    if (Array.isArray(o.value) && o.value.length === 2) {
      const v = V(
        V(o.value[1] ? o.value[1] : ht(o.value[0], 1))
      ), [z, A] = [he(o.value[0]), ce(o.value[0])], [J, re] = [he(o.value[1]), ce(o.value[1])];
      (z !== J || z === J && A !== re) && b.value.solo && Q(1, he(v), ce(v));
    } else
      o.value && !Array.isArray(o.value) && (Q(0, he(o.value), ce(o.value)), m(V()));
  }, l = () => {
    e.startDate && (Q(0, he(V(e.startDate)), ce(V(e.startDate))), b.value.count && S(0));
  }, g = (v, z) => {
    e.monthChangeOnScroll && N(e.monthChangeOnScroll !== "inverse" ? -v.deltaY : v.deltaY, z);
  }, s = (v, z, A = !1) => {
    e.monthChangeOnArrows && e.vertical === A && D(v, z);
  }, D = (v, z) => {
    N(v === "right" ? -1 : 1, z);
  }, ie = (v) => e.markers.find((z) => pe(va(v.value), va(z.date))), oe = (v, z) => {
    switch (e.sixWeeks === !0 ? "append" : e.sixWeeks) {
      case "prepend":
        return [!0, !1];
      case "center":
        return [v == 0, !0];
      case "fair":
        return [v == 0 || z > v, !0];
      case "append":
        return [!1, !1];
      default:
        return [!1, !1];
    }
  }, u = (v, z, A, J) => {
    if (e.sixWeeks && v.length < 6) {
      const re = 6 - v.length, Ue = (z.getDay() + 7 - J) % 7, wt = 6 - (A.getDay() + 7 - J) % 7, [_t, dn] = oe(Ue, wt);
      for (let mt = 1; mt <= re; mt++)
        if (dn ? !!(mt % 2) == _t : _t) {
          const Lt = v[0].days[0], cn = O(yt(Lt.value, -7), he(z));
          v.unshift({ days: cn });
        } else {
          const Lt = v[v.length - 1], cn = Lt.days[Lt.days.length - 1], Ka = O(yt(cn.value, 1), he(z));
          v.push({ days: Ka });
        }
    }
    return v;
  }, O = (v, z) => {
    const A = V(v), J = [];
    for (let re = 0; re < 7; re++) {
      const Ue = yt(A, re), qe = he(Ue) !== z;
      J.push({
        text: e.hideOffsetDates && qe ? "" : Ue.getDate(),
        value: Ue,
        current: !qe,
        classData: {}
      });
    }
    return J;
  }, X = (v, z) => {
    const A = [], J = V(Le(new Date(z, v), e.timezone)), re = V(Le(new Date(z, v + 1, 0), e.timezone)), Ue = e.weekStart, qe = Da(J, { weekStartsOn: Ue }), wt = (_t) => {
      const dn = O(_t, v);
      if (A.push({ days: dn }), !A[A.length - 1].days.some(
        (mt) => pe(He(mt.value), He(re))
      )) {
        const mt = yt(_t, 7);
        wt(mt);
      }
    };
    return wt(qe), u(A, J, re, Ue);
  }, C = (v) => (o.value = qt(V(v.value), e.timezone, e.weekStart), t("date-update", v.value), se()), ne = (v) => {
    const z = ut(V(v.value), d.hours, d.minutes, Ke());
    t("date-update", z), e.multiDates ? Gn(z, o, e.multiDatesLimit) : o.value = z, a(), ct().then(() => {
      se();
    });
  }, me = (v) => e.noDisabledRange ? Ia(n.value[0], v).some((A) => p(A)) : !1, ye = () => {
    n.value = o.value ? o.value.slice() : [], n.value.length === 2 && !(e.fixedStart || e.fixedEnd) && (n.value = []);
  }, I = (v, z) => {
    const A = [V(v.value), yt(V(v.value), +e.autoRange)];
    U(A) ? (z && F(v.value), n.value = A) : t("invalid-date", v.value);
  }, F = (v) => {
    const z = he(V(v)), A = ce(V(v));
    if (Q(0, z, A), b.value.count > 0)
      for (let J = 1; J < b.value.count; J++) {
        const re = qr(
          De(V(v), { year: k.value(J - 1), month: R.value(J - 1) })
        );
        Q(J, re.month, re.year);
      }
  }, $e = (v) => Array.isArray(o.value) && o.value.length === 2 ? e.fixedStart && (Ne(v, o.value[0]) || pe(v, o.value[0])) ? [o.value[0], v] : e.fixedEnd && (_e(v, o.value[1]) || pe(v, o.value[1])) ? [v, o.value[1]] : (t("invalid-fixed-range", v), o.value) : [], ae = (v) => {
    if (me(v.value) || !L(v.value, o.value, e.fixedStart ? 0 : 1))
      return t("invalid-date", v.value);
    n.value = $e(V(v.value));
  }, je = (v, z) => {
    if (ye(), e.autoRange)
      return I(v, z);
    if (e.fixedStart || e.fixedEnd)
      return ae(v);
    n.value[0] ? L(V(v.value), o.value) && !me(v.value) ? _e(V(v.value), V(n.value[0])) ? (n.value.unshift(V(v.value)), t("range-end", n.value[0])) : (n.value[1] = V(v.value), t("range-end", n.value[1])) : (e.autoApply && t("auto-apply-invalid", v.value), t("invalid-date", v.value)) : (n.value[0] = V(v.value), t("range-start", n.value[0]));
  }, Ke = (v = !0) => e.enableSeconds ? Array.isArray(d.seconds) ? v ? d.seconds[0] : d.seconds[1] : d.seconds : 0, vt = (v) => {
    n.value[v] = ut(
      n.value[v],
      d.hours[v],
      d.minutes[v],
      Ke(v !== 1)
    );
  }, Ge = () => {
    var v, z;
    n.value[0] && n.value[1] && +((v = n.value) == null ? void 0 : v[0]) > +((z = n.value) == null ? void 0 : z[1]) && (n.value.reverse(), t("range-start", n.value[0]), t("range-end", n.value[1]));
  }, nn = () => {
    n.value.length && (n.value[0] && !n.value[1] ? vt(0) : (vt(0), vt(1), a()), Ge(), o.value = n.value.slice(), tn(n.value, t, e.autoApply, e.modelAuto));
  }, an = (v, z = !1) => {
    if (p(v.value) || !v.current && e.hideOffsetDates)
      return t("invalid-date", v.value);
    if (e.weekPicker)
      return C(v);
    if (!e.range)
      return ne(v);
    ha(d.hours) && ha(d.minutes) && !e.multiDates && (je(v, z), nn());
  }, rn = (v, z) => {
    var J;
    Q(v, z.month, z.year), b.value.count && !b.value.solo && S(v), t("update-month-year", { instance: v, month: z.month, year: z.year }), r(b.value.solo ? v : void 0);
    const A = (J = e.flow) != null && J.length ? e.flow[e.flowStep] : void 0;
    !z.fromNav && (A === et.month || A === et.year) && a();
  }, ln = (v, z) => {
    Array.isArray(v) && v.length <= 2 && e.range ? o.value = v.map((A) => Le(V(A), z ? void 0 : e.timezone)) : Array.isArray(v) || (o.value = Le(V(v), z ? void 0 : e.timezone)), q(), e.multiCalendars && ct().then(() => E(!0));
  }, on = () => {
    e.range ? o.value && Array.isArray(o.value) && o.value[0] ? o.value = _e(V(), o.value[0]) ? [V(), o.value[0]] : [o.value[0], V()] : o.value = [V()] : o.value = V(), q();
  }, sn = () => {
    if (Array.isArray(o.value))
      if (e.multiDates) {
        const v = un();
        o.value[o.value.length - 1] = Y(v);
      } else
        o.value = o.value.map((v, z) => v && Y(v, z));
    else
      o.value = Y(o.value);
    t("time-update");
  }, un = () => Array.isArray(o.value) && o.value.length ? o.value[o.value.length - 1] : null;
  return {
    calendars: i,
    modelValue: o,
    month: k,
    year: R,
    time: d,
    disabledTimesConfig: H,
    validateTime: _,
    getCalendarDays: X,
    getMarker: ie,
    handleScroll: g,
    handleSwipe: D,
    handleArrow: s,
    selectDate: an,
    updateMonthYear: rn,
    presetDate: ln,
    selectCurrentDate: on,
    updateTime: (v, z = !0, A = !1) => {
      B(v, z, A, sn);
    }
  };
}, fo = { key: 0 }, vo = /* @__PURE__ */ Oe({
  __name: "DatePicker",
  props: {
    ...xe
  },
  emits: [
    "tooltip-open",
    "tooltip-close",
    "mount",
    "update:internal-model-value",
    "update-flow-step",
    "reset-flow",
    "auto-apply",
    "focus-menu",
    "select-date",
    "range-start",
    "range-end",
    "invalid-fixed-range",
    "time-update",
    "am-pm-change",
    "time-picker-open",
    "time-picker-close",
    "recalculate-position",
    "update-month-year",
    "auto-apply-invalid",
    "date-update",
    "invalid-date"
  ],
  setup(e, { expose: t, emit: r }) {
    const a = r, n = e, {
      calendars: o,
      month: i,
      year: d,
      modelValue: b,
      time: P,
      disabledTimesConfig: T,
      validateTime: p,
      getCalendarDays: U,
      getMarker: L,
      handleArrow: B,
      handleScroll: Y,
      handleSwipe: G,
      selectDate: h,
      updateMonthYear: _,
      presetDate: H,
      selectCurrentDate: k,
      updateTime: R
    } = co(n, a, w, l), Q = kt(), { setHoverDate: q, getDayClassData: x, clearHoverDate: se } = ml(b, n), { defaultedMultiCalendars: E } = Te(n), m = ee([]), $ = ee([]), j = ee(null), te = Ve(Q, "calendar"), f = Ve(Q, "monthYear"), y = Ve(Q, "timePicker"), N = (u) => {
      n.shadow || a("mount", u);
    };
    dt(
      o,
      () => {
        n.shadow || setTimeout(() => {
          a("recalculate-position");
        }, 0);
      },
      { deep: !0 }
    );
    const S = Z(() => (u) => U(i.value(u), d.value(u)).map((O) => ({
      ...O,
      days: O.days.map((X) => (X.marker = L(X), X.classData = x(X), X))
    })));
    function w(u) {
      var O;
      u || u === 0 ? (O = $.value[u]) == null || O.triggerTransition(i.value(u), d.value(u)) : $.value.forEach((X, C) => X.triggerTransition(i.value(C), d.value(C)));
    }
    function l() {
      a("update-flow-step");
    }
    const g = (u, O = !1) => {
      h(u, O), n.spaceConfirm && a("select-date");
    };
    return t({
      clearHoverDate: se,
      presetDate: H,
      selectCurrentDate: k,
      toggleMonthPicker: (u, O, X = 0) => {
        var C;
        (C = m.value[X]) == null || C.toggleMonthPicker(u, O);
      },
      toggleYearPicker: (u, O, X = 0) => {
        var C;
        (C = m.value[X]) == null || C.toggleYearPicker(u, O);
      },
      toggleTimePicker: (u, O, X) => {
        var C;
        (C = j.value) == null || C.toggleTimePicker(u, O, X);
      },
      handleArrow: B,
      updateMonthYear: _,
      getSidebarProps: () => ({
        modelValue: b,
        month: i,
        year: d,
        time: P,
        updateTime: R,
        updateMonthYear: _,
        selectDate: h,
        presetDate: H
      })
    }), (u, O) => (M(), W(ve, null, [
      We(en, {
        "multi-calendars": c(E).count
      }, {
        default: fe(({ instance: X, index: C }) => [
          u.disableMonthYearSelect ? K("", !0) : (M(), ge(eo, Re({
            key: 0,
            ref: (ne) => {
              ne && (m.value[C] = ne);
            },
            months: c(_a)(u.formatLocale, u.locale, u.monthNameFormat),
            years: c(jn)(u.yearRange, u.reverseYears),
            month: c(i)(X),
            year: c(d)(X),
            instance: X
          }, u.$props, {
            onMount: O[0] || (O[0] = (ne) => N(c(bt).header)),
            onResetFlow: O[1] || (O[1] = (ne) => u.$emit("reset-flow")),
            onUpdateMonthYear: (ne) => c(_)(X, ne),
            onOverlayClosed: O[2] || (O[2] = (ne) => u.$emit("focus-menu"))
          }), Ee({ _: 2 }, [
            Me(c(f), (ne, me) => ({
              name: ne,
              fn: fe((ye) => [
                le(u.$slots, ne, Pe(Fe(ye)))
              ])
            }))
          ]), 1040, ["months", "years", "month", "year", "instance", "onUpdateMonthYear"])),
          We(uo, Re({
            ref: (ne) => {
              ne && ($.value[C] = ne);
            },
            "mapped-dates": S.value(X),
            month: c(i)(X),
            year: c(d)(X),
            instance: X
          }, u.$props, {
            onSelectDate: (ne) => c(h)(ne, X !== 1),
            onHandleSpace: (ne) => g(ne, X !== 1),
            onSetHoverDate: O[3] || (O[3] = (ne) => c(q)(ne)),
            onHandleScroll: (ne) => c(Y)(ne, X),
            onHandleSwipe: (ne) => c(G)(ne, X),
            onMount: O[4] || (O[4] = (ne) => N(c(bt).calendar)),
            onResetFlow: O[5] || (O[5] = (ne) => u.$emit("reset-flow")),
            onTooltipOpen: O[6] || (O[6] = (ne) => u.$emit("tooltip-open", ne)),
            onTooltipClose: O[7] || (O[7] = (ne) => u.$emit("tooltip-close", ne))
          }), Ee({ _: 2 }, [
            Me(c(te), (ne, me) => ({
              name: ne,
              fn: fe((ye) => [
                le(u.$slots, ne, Pe(Fe({ ...ye })))
              ])
            }))
          ]), 1040, ["mapped-dates", "month", "year", "instance", "onSelectDate", "onHandleSpace", "onHandleScroll", "onHandleSwipe"])
        ]),
        _: 3
      }, 8, ["multi-calendars"]),
      u.enableTimePicker ? (M(), W("div", fo, [
        u.$slots["time-picker"] ? le(u.$slots, "time-picker", Pe(Re({ key: 0 }, { time: c(P), updateTime: c(R) }))) : (M(), ge(Wa, Re({
          key: 1,
          ref_key: "timePickerRef",
          ref: j
        }, u.$props, {
          hours: c(P).hours,
          minutes: c(P).minutes,
          seconds: c(P).seconds,
          "internal-model-value": u.internalModelValue,
          "disabled-times-config": c(T),
          "validate-time": c(p),
          onMount: O[8] || (O[8] = (X) => N(c(bt).timePicker)),
          "onUpdate:hours": O[9] || (O[9] = (X) => c(R)(X)),
          "onUpdate:minutes": O[10] || (O[10] = (X) => c(R)(X, !1)),
          "onUpdate:seconds": O[11] || (O[11] = (X) => c(R)(X, !1, !0)),
          onResetFlow: O[12] || (O[12] = (X) => u.$emit("reset-flow")),
          onOverlayClosed: O[13] || (O[13] = (X) => u.$emit("time-picker-close")),
          onOverlayOpened: O[14] || (O[14] = (X) => u.$emit("time-picker-open", X)),
          onAmPmChange: O[15] || (O[15] = (X) => u.$emit("am-pm-change", X))
        }), Ee({ _: 2 }, [
          Me(c(y), (X, C) => ({
            name: X,
            fn: fe((ne) => [
              le(u.$slots, X, Pe(Fe(ne)))
            ])
          }))
        ]), 1040, ["hours", "minutes", "seconds", "internal-model-value", "disabled-times-config", "validate-time"]))
      ])) : K("", !0)
    ], 64));
  }
}), mo = (e, t) => {
  const r = ee(), { defaultedMultiCalendars: a, defaultedConfig: n, defaultedHighlight: o } = Te(e), { modelValue: i, year: d, month: b, calendars: P } = Vt(e, t), { isDisabled: T } = Ct(e), { selectYear: p, groupedYears: U, showYearPicker: L, isDisabled: B, toggleYearPicker: Y, handleYearSelect: G, handleYear: h } = La({
    modelValue: i,
    multiCalendars: a,
    highlight: o,
    calendars: P,
    month: b,
    year: d,
    props: e,
    emit: t
  }), _ = (m, $) => [m, $].map((j) => st(j, "MMMM", { locale: e.formatLocale })).join("-"), H = Z(() => (m) => i.value ? Array.isArray(i.value) ? i.value.some(($) => Jn(m, $)) : Jn(i.value, m) : !1), k = (m) => {
    if (e.range) {
      if (Array.isArray(i.value)) {
        const $ = pe(m, i.value[0]) || pe(m, i.value[1]);
        return Xt(i.value, r.value, m) && !$;
      }
      return !1;
    }
    return !1;
  }, R = Z(() => (m) => {
    const $ = De(/* @__PURE__ */ new Date(), { year: d.value(m) });
    return sr({
      start: ir($),
      end: ur($)
    }).map((j) => {
      const te = dr(j), f = xn(j), y = T(j), N = k(te), S = typeof o.value == "function" ? o.value({ quarter: ea(te), year: ce(te) }) : !!o.value.quarters.find(
        (w) => w.quarter === ea(te) && w.year === ce(te)
      );
      return {
        text: _(te, f),
        value: te,
        active: H.value(te),
        highlighted: S,
        disabled: y,
        isBetween: N
      };
    });
  }), Q = (m) => {
    Gn(m, i, e.multiDatesLimit), t("auto-apply", !0);
  }, q = (m) => {
    const $ = qn(i, m, t);
    tn($, t, e.autoApply, e.modelAuto);
  }, x = (m) => {
    i.value = m, t("auto-apply");
  };
  return {
    defaultedConfig: n,
    defaultedMultiCalendars: a,
    groupedYears: U,
    year: d,
    isDisabled: B,
    quarters: R,
    showYearPicker: L,
    modelValue: i,
    setHoverDate: (m) => {
      r.value = m;
    },
    selectYear: p,
    selectQuarter: (m, $, j) => {
      if (!j)
        return P.value[$].month = he(xn(m)), e.multiDates ? Q(m) : e.range ? q(m) : x(m);
    },
    toggleYearPicker: Y,
    handleYearSelect: G,
    handleYear: h
  };
}, go = { class: "dp--quarter-items" }, yo = ["disabled", "onClick", "onMouseover"], ho = /* @__PURE__ */ Oe({
  compatConfig: {
    MODE: 3
  },
  __name: "QuarterPicker",
  props: {
    ...xe
  },
  emits: [
    "update:internal-model-value",
    "reset-flow",
    "overlay-closed",
    "auto-apply",
    "range-start",
    "range-end"
  ],
  setup(e, { expose: t, emit: r }) {
    const a = r, n = e, o = kt(), i = Ve(o, "yearMode"), {
      defaultedMultiCalendars: d,
      defaultedConfig: b,
      groupedYears: P,
      year: T,
      isDisabled: p,
      quarters: U,
      modelValue: L,
      showYearPicker: B,
      setHoverDate: Y,
      selectQuarter: G,
      toggleYearPicker: h,
      handleYearSelect: _,
      handleYear: H
    } = mo(n, a);
    return t({ getSidebarProps: () => ({
      modelValue: L,
      year: T,
      selectQuarter: G,
      handleYearSelect: _,
      handleYear: H
    }) }), (R, Q) => (M(), ge(en, {
      "multi-calendars": c(d).count,
      stretch: ""
    }, {
      default: fe(({ instance: q }) => [
        de("div", {
          class: "dp-quarter-picker-wrap",
          style: Xe({ minHeight: `${c(b).modeHeight}px` })
        }, [
          de("div", null, [
            We(Ua, Re(R.$props, {
              items: c(P)(q),
              instance: q,
              "show-year-picker": c(B)[q],
              year: c(T)(q),
              "is-disabled": (x) => c(p)(q, x),
              onHandleYear: (x) => c(H)(q, x),
              onYearSelect: (x) => c(_)(x, q),
              onToggleYearPicker: (x) => c(h)(q, x == null ? void 0 : x.flow, x == null ? void 0 : x.show)
            }), Ee({ _: 2 }, [
              Me(c(i), (x, se) => ({
                name: x,
                fn: fe((E) => [
                  le(R.$slots, x, Pe(Fe(E)))
                ])
              }))
            ]), 1040, ["items", "instance", "show-year-picker", "year", "is-disabled", "onHandleYear", "onYearSelect", "onToggleYearPicker"])
          ]),
          de("div", go, [
            (M(!0), W(ve, null, Me(c(U)(q), (x, se) => (M(), W("div", { key: se }, [
              de("button", {
                type: "button",
                class: be(["dp--qr-btn", {
                  "dp--qr-btn-active": x.active,
                  "dp--qr-btn-between": x.isBetween,
                  "dp--qr-btn-disabled": x.disabled,
                  "dp--highlighted": x.highlighted
                }]),
                disabled: x.disabled,
                onClick: (E) => c(G)(x.value, q, x.disabled),
                onMouseover: (E) => c(Y)(x.value)
              }, [
                R.$slots.quarter ? le(R.$slots, "quarter", {
                  key: 0,
                  value: x.value,
                  text: x.text
                }) : (M(), W(ve, { key: 1 }, [
                  rt(Ye(x.text), 1)
                ], 64))
              ], 42, yo)
            ]))), 128))
          ])
        ], 4)
      ]),
      _: 3
    }, 8, ["multi-calendars"]));
  }
}), po = ["id", "onKeydown"], bo = {
  key: 0,
  class: "dp__sidebar_left"
}, ko = {
  key: 1,
  class: "dp--preset-dates"
}, wo = ["onClick", "onKeydown"], Do = {
  key: 2,
  class: "dp__sidebar_right"
}, Mo = {
  key: 3,
  class: "dp__action_extra"
}, pa = /* @__PURE__ */ Oe({
  compatConfig: {
    MODE: 3
  },
  __name: "DatepickerMenu",
  props: {
    ...xt,
    shadow: { type: Boolean, default: !1 },
    openOnTop: { type: Boolean, default: !1 },
    internalModelValue: { type: [Date, Array], default: null },
    arrMapValues: { type: Object, default: () => ({}) },
    noOverlayFocus: { type: Boolean, default: !1 }
  },
  emits: [
    "close-picker",
    "select-date",
    "auto-apply",
    "time-update",
    "flow-step",
    "update-month-year",
    "invalid-select",
    "update:internal-model-value",
    "recalculate-position",
    "invalid-fixed-range",
    "tooltip-open",
    "tooltip-close",
    "time-picker-open",
    "time-picker-close",
    "am-pm-change",
    "range-start",
    "range-end",
    "auto-apply-invalid",
    "date-update",
    "invalid-date"
  ],
  setup(e, { expose: t, emit: r }) {
    const a = r, n = e, o = Z(() => {
      const { openOnTop: I, ...F } = n;
      return {
        ...F,
        flowStep: x.value,
        noOverlayFocus: n.noOverlayFocus
      };
    }), { setMenuFocused: i, setShiftKey: d, control: b } = Va(), P = kt(), { defaultedTextInput: T, defaultedInline: p, defaultedConfig: U } = Te(n), L = ee(null), B = ee(0), Y = ee(null), G = ee(null), h = ee(!1), _ = ee(null);
    ze(() => {
      if (!n.shadow) {
        h.value = !0, H(), window.addEventListener("resize", H);
        const I = Se(Y);
        if (I && !T.value.enabled && !p.value.enabled && (i(!0), j()), I) {
          const F = ($e) => {
            U.value.allowPreventDefault && $e.preventDefault(), it($e, U.value, !0);
          };
          I.addEventListener("pointerdown", F), I.addEventListener("mousedown", F);
        }
      }
    }), Yn(() => {
      window.removeEventListener("resize", H);
    });
    const H = () => {
      const I = Se(G);
      I && (B.value = I.getBoundingClientRect().width);
    }, { arrowRight: k, arrowLeft: R, arrowDown: Q, arrowUp: q } = ft(), { flowStep: x, updateFlowStep: se, childMount: E, resetFlow: m } = gl(n, a, _), $ = Z(() => n.monthPicker ? Ol : n.yearPicker ? Nl : n.timePicker ? Xl : n.quarterPicker ? ho : vo), j = () => {
      const I = Se(Y);
      I && I.focus({ preventScroll: !0 });
    }, te = Z(() => {
      var I;
      return ((I = _.value) == null ? void 0 : I.getSidebarProps()) || {};
    }), f = () => {
      n.openOnTop && a("recalculate-position");
    }, y = Ve(P, "action"), N = Z(() => n.monthPicker || n.yearPicker ? Ve(P, "monthYear") : n.timePicker ? Ve(P, "timePicker") : Ve(P, "shared")), S = Z(() => n.openOnTop ? "dp__arrow_bottom" : "dp__arrow_top"), w = Z(() => ({
      dp__menu_disabled: n.disabled,
      dp__menu_readonly: n.readonly
    })), l = Z(
      () => ({
        dp__menu: !0,
        dp__menu_index: !p.value.enabled,
        dp__relative: p.value.enabled,
        [n.menuClassName]: !!n.menuClassName
      })
    ), g = (I) => {
      it(I, U.value, !0);
    }, s = () => {
      n.escClose && a("close-picker");
    }, D = (I) => {
      if (n.arrowNavigation) {
        if (I === "up")
          return q();
        if (I === "down")
          return Q();
        if (I === "left")
          return R();
        if (I === "right")
          return k();
      } else
        I === "left" || I === "up" ? X("handleArrow", "left", 0, I === "up") : X("handleArrow", "right", 0, I === "down");
    }, ie = (I) => {
      d(I.shiftKey), !n.disableMonthYearSelect && I.code === "Tab" && I.target.classList.contains("dp__menu") && b.value.shiftKeyInMenu && (I.preventDefault(), it(I, U.value, !0), a("close-picker"));
    }, oe = () => {
      j(), a("time-picker-close");
    }, u = (I) => {
      var F, $e, ae;
      (F = _.value) == null || F.toggleTimePicker(!1, !1), ($e = _.value) == null || $e.toggleMonthPicker(!1, !1, I), (ae = _.value) == null || ae.toggleYearPicker(!1, !1, I);
    }, O = (I, F = 0) => {
      var $e, ae, je;
      return I === "month" ? ($e = _.value) == null ? void 0 : $e.toggleMonthPicker(!1, !0, F) : I === "year" ? (ae = _.value) == null ? void 0 : ae.toggleYearPicker(!1, !0, F) : I === "time" ? (je = _.value) == null ? void 0 : je.toggleTimePicker(!0, !1) : u(F);
    }, X = (I, ...F) => {
      var $e, ae;
      ($e = _.value) != null && $e[I] && ((ae = _.value) == null || ae[I](...F));
    }, C = () => {
      X("selectCurrentDate");
    }, ne = (I, F) => {
      X("presetDate", I, F);
    }, me = () => {
      X("clearHoverDate");
    };
    return t({
      updateMonthYear: (I, F) => {
        X("updateMonthYear", I, F);
      },
      switchView: O
    }), (I, F) => {
      var $e;
      return M(), W("div", {
        id: I.uid ? `dp-menu-${I.uid}` : void 0,
        ref_key: "dpMenuRef",
        ref: Y,
        tabindex: "0",
        role: "dialog",
        class: be(l.value),
        onMouseleave: me,
        onClick: g,
        onKeydown: [
          ue(s, ["esc"]),
          F[18] || (F[18] = ue(ke((ae) => D("left"), ["prevent"]), ["left"])),
          F[19] || (F[19] = ue(ke((ae) => D("up"), ["prevent"]), ["up"])),
          F[20] || (F[20] = ue(ke((ae) => D("down"), ["prevent"]), ["down"])),
          F[21] || (F[21] = ue(ke((ae) => D("right"), ["prevent"]), ["right"])),
          ie
        ]
      }, [
        (I.disabled || I.readonly) && c(p).enabled ? (M(), W("div", {
          key: 0,
          class: be(w.value)
        }, null, 2)) : K("", !0),
        !c(p).enabled && !I.teleportCenter ? (M(), W("div", {
          key: 1,
          class: be(S.value)
        }, null, 2)) : K("", !0),
        de("div", {
          ref_key: "innerMenuRef",
          ref: G,
          class: be({
            dp__menu_content_wrapper: (($e = I.presetDates) == null ? void 0 : $e.length) || !!I.$slots["left-sidebar"] || !!I.$slots["right-sidebar"]
          }),
          style: Xe({ "--dp-menu-width": `${B.value}px` })
        }, [
          I.$slots["left-sidebar"] ? (M(), W("div", bo, [
            le(I.$slots, "left-sidebar", Pe(Fe(te.value)))
          ])) : K("", !0),
          I.presetDates.length ? (M(), W("div", ko, [
            (M(!0), W(ve, null, Me(I.presetDates, (ae, je) => (M(), W(ve, { key: je }, [
              ae.slot ? le(I.$slots, ae.slot, {
                key: 0,
                presetDate: ne,
                label: ae.label,
                value: ae.value
              }) : (M(), W("button", {
                key: 1,
                type: "button",
                style: Xe(ae.style || {}),
                class: "dp__btn dp--preset-range",
                onClick: ke((Ke) => ne(ae.value, ae.noTz), ["prevent"]),
                onKeydown: [
                  ue(ke((Ke) => ne(ae.value, ae.noTz), ["prevent"]), ["enter"]),
                  ue(ke((Ke) => ne(ae.value, ae.noTz), ["prevent"]), ["space"])
                ]
              }, Ye(ae.label), 45, wo))
            ], 64))), 128))
          ])) : K("", !0),
          de("div", {
            ref_key: "calendarWrapperRef",
            ref: L,
            class: "dp__instance_calendar",
            role: "document"
          }, [
            (M(), ge(Nn($.value), Re({
              ref_key: "dynCmpRef",
              ref: _
            }, o.value, {
              "flow-step": c(x),
              onMount: c(E),
              onUpdateFlowStep: c(se),
              onResetFlow: c(m),
              onFocusMenu: j,
              onSelectDate: F[0] || (F[0] = (ae) => I.$emit("select-date")),
              onDateUpdate: F[1] || (F[1] = (ae) => I.$emit("date-update", ae)),
              onTooltipOpen: F[2] || (F[2] = (ae) => I.$emit("tooltip-open", ae)),
              onTooltipClose: F[3] || (F[3] = (ae) => I.$emit("tooltip-close", ae)),
              onAutoApply: F[4] || (F[4] = (ae) => I.$emit("auto-apply", ae)),
              onRangeStart: F[5] || (F[5] = (ae) => I.$emit("range-start", ae)),
              onRangeEnd: F[6] || (F[6] = (ae) => I.$emit("range-end", ae)),
              onInvalidFixedRange: F[7] || (F[7] = (ae) => I.$emit("invalid-fixed-range", ae)),
              onTimeUpdate: F[8] || (F[8] = (ae) => I.$emit("time-update")),
              onAmPmChange: F[9] || (F[9] = (ae) => I.$emit("am-pm-change", ae)),
              onTimePickerOpen: F[10] || (F[10] = (ae) => I.$emit("time-picker-open", ae)),
              onTimePickerClose: oe,
              onRecalculatePosition: f,
              onUpdateMonthYear: F[11] || (F[11] = (ae) => I.$emit("update-month-year", ae)),
              onAutoApplyInvalid: F[12] || (F[12] = (ae) => I.$emit("auto-apply-invalid", ae)),
              onInvalidDate: F[13] || (F[13] = (ae) => I.$emit("invalid-date", ae)),
              "onUpdate:internalModelValue": F[14] || (F[14] = (ae) => I.$emit("update:internal-model-value", ae))
            }), Ee({ _: 2 }, [
              Me(N.value, (ae, je) => ({
                name: ae,
                fn: fe((Ke) => [
                  le(I.$slots, ae, Pe(Fe({ ...Ke })))
                ])
              }))
            ]), 1040, ["flow-step", "onMount", "onUpdateFlowStep", "onResetFlow"]))
          ], 512),
          I.$slots["right-sidebar"] ? (M(), W("div", Do, [
            le(I.$slots, "right-sidebar", Pe(Fe(te.value)))
          ])) : K("", !0),
          I.$slots["action-extra"] ? (M(), W("div", Mo, [
            I.$slots["action-extra"] ? le(I.$slots, "action-extra", {
              key: 0,
              selectCurrentDate: C
            }) : K("", !0)
          ])) : K("", !0)
        ], 6),
        !I.autoApply || c(U).keepActionRow ? (M(), ge(Ml, Re({
          key: 2,
          "menu-mount": h.value
        }, o.value, {
          "calendar-width": B.value,
          onClosePicker: F[15] || (F[15] = (ae) => I.$emit("close-picker")),
          onSelectDate: F[16] || (F[16] = (ae) => I.$emit("select-date")),
          onInvalidSelect: F[17] || (F[17] = (ae) => I.$emit("invalid-select")),
          onSelectNow: C
        }), Ee({ _: 2 }, [
          Me(c(y), (ae, je) => ({
            name: ae,
            fn: fe((Ke) => [
              le(I.$slots, ae, Pe(Fe({ ...Ke })))
            ])
          }))
        ]), 1040, ["menu-mount", "calendar-width"])) : K("", !0)
      ], 42, po);
    };
  }
}), $o = typeof window < "u" ? window : void 0, $n = () => {
}, To = (e) => Za() ? (Qa(e), !0) : !1, Ao = (e, t, r, a) => {
  if (!e)
    return $n;
  let n = $n;
  const o = dt(
    () => c(e),
    (d) => {
      n(), d && (d.addEventListener(t, r, a), n = () => {
        d.removeEventListener(t, r, a), n = $n;
      });
    },
    { immediate: !0, flush: "post" }
  ), i = () => {
    o(), n();
  };
  return To(i), i;
}, So = (e, t, r, a = {}) => {
  const { window: n = $o, event: o = "pointerdown" } = a;
  return n ? Ao(n, o, (d) => {
    const b = Se(e), P = Se(t);
    !b || !P || b === d.target || d.composedPath().includes(b) || d.composedPath().includes(P) || r(d);
  }, { passive: !0 }) : void 0;
}, Po = /* @__PURE__ */ Oe({
  compatConfig: {
    MODE: 3
  },
  __name: "VueDatePicker",
  props: {
    ...xt
  },
  emits: [
    "update:model-value",
    "update:model-timezone-value",
    "text-submit",
    "closed",
    "cleared",
    "open",
    "focus",
    "blur",
    "internal-model-change",
    "recalculate-position",
    "flow-step",
    "update-month-year",
    "invalid-select",
    "invalid-fixed-range",
    "tooltip-open",
    "tooltip-close",
    "time-picker-open",
    "time-picker-close",
    "am-pm-change",
    "range-start",
    "range-end",
    "date-update",
    "invalid-date"
  ],
  setup(e, { expose: t, emit: r }) {
    const a = r, n = e, o = kt(), i = ee(!1), d = Zt(n, "modelValue"), b = Zt(n, "timezone"), P = ee(null), T = ee(null), p = ee(null), U = ee(!1), L = ee(null), B = ee(!1), { setMenuFocused: Y, setShiftKey: G } = Va(), { clearArrowNav: h } = ft(), { mapDatesArrToMap: _, validateDate: H, isValidTime: k } = Ct(n), { defaultedTransitions: R, defaultedTextInput: Q, defaultedInline: q, defaultedConfig: x } = Te(n), { menuTransition: se, showTransition: E } = Ht(R);
    ze(() => {
      s(n.modelValue), ct().then(() => {
        q.value.enabled || (S(L.value).addEventListener("scroll", ne), window.addEventListener("resize", me));
      }), q.value.enabled && (i.value = !0);
    });
    const m = Z(() => _());
    Yn(() => {
      if (!q.value.enabled) {
        const A = S(L.value);
        A && A.removeEventListener("scroll", ne), window.removeEventListener("resize", me);
      }
    });
    const $ = Ve(o, "all", n.presetDates), j = Ve(o, "input");
    dt(
      [d, b],
      () => {
        s(d.value);
      },
      { deep: !0 }
    );
    const { openOnTop: te, menuStyle: f, xCorrect: y, setMenuPosition: N, getScrollableParent: S, shadowRender: w } = cl({
      menuRef: P,
      menuRefInner: T,
      inputRef: p,
      pickerWrapperRef: L,
      inline: q,
      emit: a,
      props: n,
      slots: o
    }), {
      inputValue: l,
      internalModelValue: g,
      parseExternalModelValue: s,
      emitModelValue: D,
      formatInputValue: ie,
      checkBeforeEmit: oe
    } = ul(a, n, U), u = Z(
      () => ({
        dp__main: !0,
        dp__theme_dark: n.dark,
        dp__theme_light: !n.dark,
        dp__flex_display: q.value.enabled,
        dp__flex_display_with_input: q.value.input
      })
    ), O = Z(() => n.dark ? "dp__theme_dark" : "dp__theme_light"), X = Z(() => n.teleport ? {
      to: typeof n.teleport == "boolean" ? "body" : n.teleport,
      disabled: q.value.enabled
    } : { class: "dp__outer_menu_wrap" }), C = Z(() => q.value.enabled && (n.timePicker || n.monthPicker || n.yearPicker || n.quarterPicker)), ne = () => {
      i.value && (x.value.closeOnScroll ? Ge() : N());
    }, me = () => {
      i.value && N();
    }, ye = () => {
      !n.disabled && !n.readonly && (w(pa, n), N(!1), i.value = !0, i.value && a("open"), i.value || vt(), s(n.modelValue));
    }, I = () => {
      var A;
      l.value = "", vt(), (A = p.value) == null || A.setParsedDate(null), a("update:model-value", null), a("update:model-timezone-value", null), a("cleared"), x.value.closeOnClearValue && Ge();
    }, F = () => {
      const A = g.value;
      return !A || !Array.isArray(A) && H(A) ? !0 : Array.isArray(A) ? A.length === 2 && H(A[0]) && H(A[1]) ? !0 : n.partialRange && !n.timePicker ? H(A[0]) : !1 : !1;
    }, $e = () => {
      oe() && F() ? (D(), Ge()) : a("invalid-select", g.value);
    }, ae = (A) => {
      je(), D(), x.value.closeOnAutoApply && !A && Ge();
    }, je = () => {
      p.value && Q.value.enabled && p.value.setParsedDate(g.value);
    }, Ke = (A = !1) => {
      n.autoApply && k(g.value) && F() && (n.range && Array.isArray(g.value) ? (n.partialRange || g.value.length === 2) && ae(A) : ae(A));
    }, vt = () => {
      Q.value.enabled || (g.value = null);
    }, Ge = () => {
      q.value.enabled || (i.value && (i.value = !1, y.value = !1, Y(!1), G(!1), h(), a("closed"), l.value && s(d.value)), vt(), a("blur"));
    }, nn = (A, J, re = !1) => {
      if (!A) {
        g.value = null;
        return;
      }
      const Ue = Array.isArray(A) ? !A.some((wt) => !H(wt)) : H(A), qe = k(A);
      Ue && qe && (g.value = A, J && (B.value = re, $e(), a("text-submit")));
    }, an = () => {
      n.autoApply && k(g.value) && D(), je();
    }, rn = () => i.value ? Ge() : ye(), ln = (A) => {
      g.value = A;
    }, on = () => {
      Q.value.enabled && (U.value = !0, ie()), a("focus");
    }, sn = () => {
      if (Q.value.enabled && (U.value = !1, s(n.modelValue), B.value)) {
        const A = jr(L.value);
        A == null || A.focus();
      }
      a("blur");
    }, un = (A) => {
      T.value && T.value.updateMonthYear(0, {
        month: da(A.month),
        year: da(A.year)
      });
    }, Zn = (A) => {
      s(A ?? n.modelValue);
    }, v = (A, J) => {
      var re;
      (re = T.value) == null || re.switchView(A, J);
    }, z = (A) => x.value.onClickOutside ? x.value.onClickOutside(A) : Ge();
    return So(P, p, () => z(F)), t({
      closeMenu: Ge,
      selectDate: $e,
      clearValue: I,
      openMenu: ye,
      onScroll: ne,
      formatInputValue: ie,
      // exposed for testing purposes
      updateInternalModelValue: ln,
      // modify internal modelValue
      setMonthYear: un,
      parseModel: Zn,
      switchView: v
    }), (A, J) => (M(), W("div", {
      ref_key: "pickerWrapperRef",
      ref: L,
      class: be(u.value)
    }, [
      We(bl, Re({
        ref_key: "inputRef",
        ref: p,
        "input-value": c(l),
        "onUpdate:inputValue": J[0] || (J[0] = (re) => Xn(l) ? l.value = re : null),
        "is-menu-open": i.value
      }, A.$props, {
        onClear: I,
        onOpen: ye,
        onSetInputDate: nn,
        onSetEmptyDate: c(D),
        onSelectDate: $e,
        onToggle: rn,
        onClose: Ge,
        onFocus: on,
        onBlur: sn,
        onRealBlur: J[1] || (J[1] = (re) => U.value = !1)
      }), Ee({ _: 2 }, [
        Me(c(j), (re, Ue) => ({
          name: re,
          fn: fe((qe) => [
            le(A.$slots, re, Pe(Fe(qe)))
          ])
        }))
      ]), 1040, ["input-value", "is-menu-open", "onSetEmptyDate"]),
      We(Pt, {
        name: c(se)(c(te)),
        css: c(E) && !c(q).enabled
      }, {
        default: fe(() => [
          i.value ? (M(), ge(Nn(A.teleport ? Xa : "div"), Re({
            key: 0,
            ref_key: "dpWrapMenuRef",
            ref: P
          }, X.value, {
            class: { "dp--menu-wrapper": !c(q).enabled },
            style: c(q).enabled ? void 0 : c(f)
          }), {
            default: fe(() => [
              We(pa, Re({
                ref_key: "dpMenuRef",
                ref: T
              }, A.$props, {
                "internal-model-value": c(g),
                "onUpdate:internalModelValue": J[2] || (J[2] = (re) => Xn(g) ? g.value = re : null),
                class: { [O.value]: !0, "dp--menu-wrapper": A.teleport },
                style: A.teleport ? c(f) : void 0,
                "open-on-top": c(te),
                "arr-map-values": m.value,
                "no-overlay-focus": C.value,
                onClosePicker: Ge,
                onSelectDate: $e,
                onAutoApply: Ke,
                onTimeUpdate: an,
                onFlowStep: J[3] || (J[3] = (re) => A.$emit("flow-step", re)),
                onUpdateMonthYear: J[4] || (J[4] = (re) => A.$emit("update-month-year", re)),
                onInvalidSelect: J[5] || (J[5] = (re) => A.$emit("invalid-select", c(g))),
                onAutoApplyInvalid: J[6] || (J[6] = (re) => A.$emit("invalid-select", re)),
                onInvalidFixedRange: J[7] || (J[7] = (re) => A.$emit("invalid-fixed-range", re)),
                onRecalculatePosition: c(N),
                onTooltipOpen: J[8] || (J[8] = (re) => A.$emit("tooltip-open", re)),
                onTooltipClose: J[9] || (J[9] = (re) => A.$emit("tooltip-close", re)),
                onTimePickerOpen: J[10] || (J[10] = (re) => A.$emit("time-picker-open", re)),
                onTimePickerClose: J[11] || (J[11] = (re) => A.$emit("time-picker-close", re)),
                onAmPmChange: J[12] || (J[12] = (re) => A.$emit("am-pm-change", re)),
                onRangeStart: J[13] || (J[13] = (re) => A.$emit("range-start", re)),
                onRangeEnd: J[14] || (J[14] = (re) => A.$emit("range-end", re)),
                onDateUpdate: J[15] || (J[15] = (re) => A.$emit("date-update", re)),
                onInvalidDate: J[16] || (J[16] = (re) => A.$emit("invalid-date", re))
              }), Ee({ _: 2 }, [
                Me(c($), (re, Ue) => ({
                  name: re,
                  fn: fe((qe) => [
                    le(A.$slots, re, Pe(Fe({ ...qe })))
                  ])
                }))
              ]), 1040, ["internal-model-value", "class", "style", "open-on-top", "arr-map-values", "no-overlay-focus", "onRecalculatePosition"])
            ]),
            _: 3
          }, 16, ["class", "style"])) : K("", !0)
        ]),
        _: 3
      }, 8, ["name", "css"])
    ], 2));
  }
}), ja = /* @__PURE__ */ (() => {
  const e = Po;
  return e.install = (t) => {
    t.component("Vue3DatePicker", e);
  }, e;
})(), Co = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: ja
}, Symbol.toStringTag, { value: "Module" }));
Object.entries(Co).forEach(([e, t]) => {
  e !== "default" && (ja[e] = t);
});
export {
  ja as default
};
